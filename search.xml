<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python中的属性访问与描述符]]></title>
      <url>%2FPython%2FPython%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[在Python中，对于一个对象的属性访问，我们一般采用的是点(.)属性运算符进行操作。例如，有一个类实例对象foo，它有一个name属性，那便可以使用foo.name对此属性进行访问。一般而言，点(.)属性运算符比较直观，也是我们经常碰到的一种属性访问方式。然而，在点(.)属性运算符的背后却是别有洞天，值得我们对对象的属性访问进行探讨。 在进行对象属性访问的分析之前，我们需要先了解一下对象怎么表示其属性。为了便于说明，本文以新式类为例。有关新式类和旧式类的区别，大家可以查看Python官方文档。 对象的属性Python中，“一切皆对象”。我们可以给对象设置各种属性。先来看一个简单的例子： 123456789class Animal(object): run = Trueclass Dog(Animal): fly = False def __init__(self, age): self.age = age def sound(self): return "wang wang~" 上面的例子中，我们定义了两个类。类Animal定义了一个属性run；类Dog继承自Animal，定义了一个属性fly和两个函数。接下来，我们实例化一个对象。对象的属性可以从特殊属性__dict__中查看。 12345678910111213141516171819# 实例化一个对象dog&gt;&gt;&gt; dog = Dog(1)# 查看dog对象的属性&gt;&gt;&gt; dog.__dict__&#123;'age': 1&#125;# 查看类Dog的属性&gt;&gt;&gt; Dog.__dict__dict_proxy(&#123;'__doc__': None, '__init__': &lt;function __main__.__init__&gt;, '__module__': '__main__', 'fly': False, 'sound': &lt;function __main__.sound&gt;&#125;)# 查看类Animal的属性&gt;&gt;&gt; Animal.__dict__dict_proxy(&#123;'__dict__': &lt;attribute '__dict__' of 'Animal' objects&gt;, '__doc__': None, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'Animal' objects&gt;, 'run': True&#125;) 由上面的例子可以看出：属性在哪个对象上定义，便会出现在哪个对象的__dict__中。例如： 类Animal定义了一个属性run，那这个run属性便只会出现在类Animal的__dict__中，而不会出现在其子类中。 类Dog定义了一个属性fly和两个函数，那这些属性和方法便会出现在类Dog的__dict__中，同时它们也不会出现在实例的__dict__中。 实例对象dog的__dict__中只出现了一个属性age，这是在初始化实例对象的时候添加的，它没有父类的属性和方法。 由此可知：Python中对象的属性具有 “层次性”，属性在哪个对象上定义，便会出现在哪个对象的__dict__中。 在这里我们首先了解的是属性值会存储在对象的__dict__中，查找也会在对象的__dict__中进行查找的。至于Python对象进行属性访问时，会按照怎样的规则来查找属性值呢？这个问题在后文中进行讨论。 对象属性访问与特殊方法__getattribute__正如前面所述，Python的属性访问方式很直观，使用点属性运算符。在新式类中，对对象属性的访问，都会调用特殊方法__getattribute__。__getattribute__允许我们在访问对象属性时自定义访问行为，但是使用它特别要小心无限递归的问题。 还是以上面的情景为例： 12345678910111213141516class Animal(object): run = Trueclass Dog(Animal): fly = False def __init__(self, age): self.age = age # 重写__getattribute__。需要注意的是重写的方法中不能 # 使用对象的点运算符访问属性，否则使用点运算符访问属性时， # 会再次调用__getattribute__。这样就会陷入无限递归。 # 可以使用super()方法避免这个问题。 def __getattribute__(self, key): print "calling __getattribute__\n" return super(Dog, self).__getattribute__(key) def sound(self): return "wang wang~" 上面的例子中我们重写了__getattribute__方法。注意我们使用了super()方法来避免无限循环问题。下面我们实例化一个对象来说明访问对象属性时__getattribute__的特性。 12345678910111213141516171819202122# 实例化对象dog&gt;&gt;&gt; dog = Dog(1)# 访问dog对象的age属性&gt;&gt;&gt; dog.agecalling __getattribute__1# 访问dog对象的fly属性&gt;&gt;&gt; dog.flycalling __getattribute__False# 访问dog对象的run属性&gt;&gt;&gt; dog.runcalling __getattribute__True# 访问dog对象的sound方法&gt;&gt;&gt; dog.soundcalling __getattribute__&lt;bound method Dog.sound of &lt;__main__.Dog object at 0x0000000005A90668&gt;&gt; 由上面的验证可知，__getattribute__是实例对象查找属性或方法的入口。实例对象访问属性或方法时都需要调用到__getattribute__，之后才会根据一定的规则在各个__dict__中查找相应的属性值或方法对象，若没有找到则会调用__getattr__（后面会介绍到）。__getattribute__是Python中的一个内置方法，关于其底层实现可以查看相关官方文档，后面将要介绍的属性访问规则就是依赖于__getattribute__的。 对象属性控制在继续介绍后面相关内容之前，让我们先来了解一下Python中和对象属性控制相关的相关方法。 __getattr__(self, name) __getattr__可以用来在当用户试图访问一个根本不存在（或者暂时不存在）的属性时，来定义类的行为。前面讲到过，当__getattribute__方法找不到属性时，最终会调用__getattr__方法。它可以用于捕捉错误的以及灵活地处理AttributeError。只有当试图访问不存在的属性时它才会被调用。 __setattr__(self, name, value) __setattr__方法允许你自定义某个属性的赋值行为，不管这个属性存在与否，都可以对任意属性的任何变化都定义自己的规则。关于__setattr__有两点需要说明：第一，使用它时必须小心，不能写成类似self.name = &quot;Tom&quot;这样的形式，因为这样的赋值语句会调用__setattr__方法，这样会让其陷入无限递归；第二，你必须区分 对象属性 和 类属性 这两个概念。后面的例子中会对此进行解释。 __delattr__(self, name) __delattr__用于处理删除属性时的行为。和__setattr__方法要注意无限递归的问题，重写该方法时不要有类似del self.name的写法。 还是以上面的例子进行说明，不过在这里我们要重写三个属性控制方法。 12345678910111213141516171819class Animal(object): run = Trueclass Dog(Animal): fly = False def __init__(self, age): self.age = age def __getattr__(self, name): print "calling __getattr__\n" if name == 'adult': return True if self.age &gt;= 2 else False else: raise AttributeError def __setattr__(self, name, value): print "calling __setattr__" super(Dog, self).__setattr__(name, value) def __delattr__(self, name): print "calling __delattr__" super(Dog, self).__delattr__(name) 以下进行验证。首先是__getattr__: 12345678910111213141516171819202122232425262728293031# 创建实例对象dog&gt;&gt;&gt; dog = Dog(1)calling __setattr__# 检查一下dog和Dog的__dict__&gt;&gt;&gt; dog.__dict__&#123;'age': 1&#125;&gt;&gt;&gt; Dog.__dict__dict_proxy(&#123;'__delattr__': &lt;function __main__.__delattr__&gt;, '__doc__': None, '__getattr__': &lt;function __main__.__getattr__&gt;, '__init__': &lt;function __main__.__init__&gt;, '__module__': '__main__', '__setattr__': &lt;function __main__.__setattr__&gt;, 'fly': False&#125;)# 获取dog的age属性&gt;&gt;&gt; dog.age1# 获取dog的adult属性。# 由于__getattribute__没有找到相应的属性，所以调用__getattr__。&gt;&gt;&gt; dog.adultcalling __getattr__False# 调用一个不存在的属性name，__getattr__捕获AttributeError错误&gt;&gt;&gt; dog.namecalling __getattr__Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 10, in __getattr__AttributeError 可以看到，属性访问时，当访问一个不存在的属性时触发__getattr__，它会对访问行为进行控制。接下来是__setattr__： 1234567891011121314151617181920212223242526272829# 给dog.age赋值，会调用__setattr__方法&gt;&gt;&gt; dog.age = 2calling __setattr__&gt;&gt;&gt; dog.age2# 先调用dog.fly时会返回False，这时因为Dog类属性中有fly属性；# 之后再给dog.fly赋值，触发__setattr__方法。&gt;&gt;&gt; dog.flyFalse&gt;&gt;&gt; dog.fly = Truecalling __setattr__# 再次查看dog.fly的值以及dog和Dog的__dict__;# 可以看出对dog对象进行赋值，会在dog对象的__dict__中添加了一条对象属性；# 然而，Dog类属性没有发生变化# 注意：dog对象和Dog类中都有fly属性，访问时会选择哪个呢？&gt;&gt;&gt; dog.flyTrue&gt;&gt;&gt; dog.__dict__&#123;'age': 2, 'fly': True&#125;&gt;&gt;&gt; Dog.__dict__dict_proxy(&#123;'__delattr__': &lt;function __main__.__delattr__&gt;, '__doc__': None, '__getattr__': &lt;function __main__.__getattr__&gt;, '__init__': &lt;function __main__.__init__&gt;, '__module__': '__main__', '__setattr__': &lt;function __main__.__setattr__&gt;, 'fly': False&#125;) 实例对象的__setattr__方法可以定义属性的赋值行为，不管属性是否存在。当属性存在时，它会改变其值；当属性不存在时，它会添加一个对象属性信息到对象的__dict__中，然而这并不改变类的属性。从上面的例子可以看出来。 最后，看一下__delattr__： 123456# 由于上面的例子中我们为dog设置了fly属性，现在删除它触发__delattr__方法&gt;&gt;&gt; del dog.flycalling __delattr__# 再次查看dog对象的__dict__，发现和fly属性相关的信息被删除&gt;&gt;&gt; dog.__dict__&#123;'age': 2&#125; 描述符描述符是Python 2.2 版本中引进来的新概念。描述符一般用于实现对象系统的底层功能， 包括绑定和非绑定方法、类方法、静态方法特特性等。关于描述符的概念，官方并没有明确的定义，可以在网上查阅相关资料。这里我从自己的认识谈一些想法，如有不当之处还请包涵。 在前面我们了解了对象属性访问和行为控制的一些特殊方法，例如__getattribute__、__getattr__、__setattr__、__delattr__。以我的理解来看，这些方法应当具有属性的”普适性”，可以用于属性查找、设置、删除的一般方法，也就是说所有的属性都可以使用这些方法实现属性的查找、设置、删除等操作。但是，这并不能很好地实现对某个具体属性的访问控制行为。例如，上例中假如要实现dog.age属性的类型设置（只能是整数），如果单单去修改__setattr__方法满足它，那这个方法便有可能不能支持其他的属性设置。 在类中设置属性的控制行为不能很好地解决问题，Python给出的方案是：__getattribute__、__getattr__、__setattr__、__delattr__等方法用来实现属性查找、设置、删除的一般逻辑，而对属性的控制行为就由属性对象来控制。这里单独抽离出来一个属性对象，在属性对象中定义这个属性的查找、设置、删除行为。这个属性对象就是描述符。 描述符对象一般是作为其他类对象的属性而存在。在其内部定义了三个方法用来实现属性对象的查找、设置、删除行为。这三个方法分别是： get(self, instance, owner)：定义当试图取出描述符的值时的行为。 set(self, instance, value)：定义当描述符的值改变时的行为。 delete(self, instance)：定义当描述符的值被删除时的行为。 其中：instance为把描述符对象作为属性的对象实例； owner为instance的类对象。 以下以官方的一个例子进行说明： 1234567891011121314151617class RevealAccess(object): def __init__(self, initval=None, name='var'): self.val = initval self.name = name def __get__(self, obj, objtype): print 'Retrieving', self.name return self.val def __set__(self, obj, val): print 'Updating', self.name self.val = valclass MyClass(object): x = RevealAccess(10, 'var "x"') y = 5 以上定义了两个类。其中RevealAccess类的实例是作为MyClass类属性x的值存在的。而且RevealAccess类定义了__get__、__set__方法，它是一个描述符对象。注意，描述符对象的__get__、__set__方法中使用了诸如self.val和self.val = val等语句，这些语句会调用__getattribute__、__setattr__等方法，这也说明了__getattribute__、__setattr__等方法在控制访问对象属性上的一般性（一般性是指对于所有属性它们的控制行为一致），以及__get__、__set__等方法在控制访问对象属性上的特殊性（特殊性是指它针对某个特定属性可以定义不同的行为）。 以下进行验证： 12345678910111213141516171819202122232425262728293031323334353637383940414243# 创建Myclass类的实例m&gt;&gt;&gt; m = MyClass()# 查看m和MyClass的__dict__&gt;&gt;&gt; m.__dict__&#123;&#125;&gt;&gt;&gt; MyClass.__dict__dict_proxy(&#123;'__dict__': &lt;attribute '__dict__' of 'MyClass' objects&gt;, '__doc__': None, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'MyClass' objects&gt;, 'x': &lt;__main__.RevealAccess at 0x5130080&gt;, 'y': 5&#125;)# 访问m.x。会先触发__getattribute__方法# 由于x属性的值是一个描述符，会触发它的__get__方法&gt;&gt;&gt; m.xRetrieving var "x"10# 设置m.x的值。对描述符进行赋值，会触发它的__set__方法# 在__set__方法中还会触发__setattr__方法（self.val = val）&gt;&gt;&gt; m.x = 20Updating var "x"# 再次访问m.x&gt;&gt;&gt; m.xRetrieving var "x"20# 查看m和MyClass的__dict__，发现这与对描述符赋值之前一样。# 这一点与一般属性的赋值不同，可参考上述的__setattr__方法。# 之所以前后没有发生变化，是因为变化体现在描述符对象上，# 而不是实例对象m和类MyClass上。&gt;&gt;&gt; m.__dict__&#123;&#125;&gt;&gt;&gt; MyClass.__dict__dict_proxy(&#123;'__dict__': &lt;attribute '__dict__' of 'MyClass' objects&gt;, '__doc__': None, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'MyClass' objects&gt;, 'x': &lt;__main__.RevealAccess at 0x5130080&gt;, 'y': 5&#125;) 上面的例子对描述符进行了一定的解释，不过对描述符还需要更进一步的探讨和分析，这个工作先留待以后继续进行。 最后，还需要注意一点：描述符有数据描述符和非数据描述符之分。 只要至少实现__get__、__set__、__delete__方法中的一个就可以认为是描述符； 只实现__get__方法的对象是非数据描述符，意味着在初始化之后它们只能被读取； 同时实现__get__和__set__的对象是数据描述符，意味着这种属性是可读写的。 属性访问的优先规则在以上的讨论中，我们一直回避着一个问题，那就是属性访问时的优先规则。我们了解到，属性一般都在__dict__中存储，但是在访问属性时，在对象属性、类属型、基类属性中以怎样的规则来查询属性呢？以下对Python中属性访问的规则进行分析。 由上述的分析可知，属性访问的入口点是__getattribute__方法。它的实现中定义了Python中属性访问的优先规则。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Python/Python中的属性访问与描述符/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python中的作用域规则和闭包简析]]></title>
      <url>%2FPython%2FPython%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99%E5%92%8C%E9%97%AD%E5%8C%85%E7%AE%80%E6%9E%90%2F</url>
      <content type="text"><![CDATA[在对Python中的闭包进行简单分析之前，我们先了解一下Python中的作用域规则。关于Python中作用域的详细知识，有很多的博文都进行了介绍。这里我们先从一个简单的例子入手。 Python中的作用域假设在交互式命令行中定义如下的函数： 123456&gt;&gt;&gt; a = 1&gt;&gt;&gt; def foo(): b = 2 c = 3 print "locals: %s" % locals() return "result: %d" % (a + b +c) 上述代码先给a赋值1，紧接着定义了一个函数：foo()。在函数foo()中我们定义了两个整数b和c，函数的返回值为a、b、c三个数的和。 对上述函数进行验证： 1234# result&gt;&gt;&gt; foo()locals: &#123;'c': 3, 'b': 2&#125;result: 6 根据验证的结果，foo()函数的返回值为6。上述的函数定义中只有b和c两个变量的赋值，那调用函数是如何判断a的值呢？这涉及到函数的作用域规则。本文摘录《Python参考手册（第4版）》中的相关论述： 每次执行一个函数时， 就会创建心得局部命名空间。该命名空间代表一个局部环境，其中包含函数参数的名称和在函数体内赋值的变量名称。解析这些名称时： 解释器将首先搜索局部命名空间； 如果没有找到匹配的名称，它就会搜索全局命名空间（函数的全局命名空间始终是定义该函数的模块）； 如果解释器在全局命名空间中也找不到匹配值，最终会检查内置命名空间； 如果在内置命名空间中也找不到匹配值，就会引发NameError异常。 对应于上面的例子，foo函数首先会在局部命名空间中找三个变量的匹配值。上述代码中的locals()方法给出了foo函数局部命名空间的内容。可以看出，局部命名空间是一个字典，包含b和c的值，这是因为我们在foo函数中定义了这两个变量。然而，局部命名空间中不包含a的值，所以就需要在全局命名空间中寻找。可以使用__globals__获取一个函数的局部命名空间。 123# foo函数的全局命名空间&gt;&gt;&gt; foo.__globals__&#123;'a': 1, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__package__': None, '__name__': '__main__', 'foo': &lt;function foo at 0x0000000004613518&gt;, '__doc__': None&#125; foo函数的全局命名空间中包含了内置函数模块、foo函数、变量a以及其他的一些参数。由于在foo函数的全局命名空间中找到了变量a，foo函数便返回三个变量的和。 闭包上述的Python作用域规则具有普遍性。然而，在Python中“一切皆对象”，函数也不例外。这也就是说可以把函数当作参数传递给其他的函数，也可以放在数据结构中，还可以作为函数的返回结果。在这种情况下，Python的作用域规则会发生什么变化呢？我们还是举一个例子： 1234567&gt;&gt;&gt; def foo(): a = 1 def bar(): b = 2 c = 3 return a + b + c return bar 在这个例子中，我们定义了一个函数foo，并对变量a赋值。不过与之前的例子不同的是，在函数foo中我们还嵌套了一个函数bar，并且还定义了两个变量，这个函数是作为函数foo的返回值。根据上面的作用域规则，函数foo的局部作用域既不是函数bar的局部作用域，也不是它的全局作用域，那函数bar能否正确匹配变量a的值呢？我们我们来验证一下这个函数是否能够正常运行。 123456789# 调用函数foo()&gt;&gt;&gt; bar = foo()# 返回值bar是一个函数&gt;&gt;&gt; bar&lt;function bar at 0x00000000045F3588&gt;# 调用bar()&gt;&gt;&gt; bar()# 结果显示为三个变量之和6 以上的验证结果说明，在上述嵌套的函数中，内部函数可以正确地引用外部函数的变量，即使外部的函数已经返回。 这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为： 闭包。内部函数可以访问外部函数变量的特点很像将外部函数的变量直接“打包”到内部函数中一样，我们也可以这样理解闭包：将组成函数的语句以及执行这些语句的环境“打包”在一起时得到的对象称为闭包。 和闭包相关的几个对象为了了解闭包是怎么实现内部函数对外部函数变量的引用，还需要对闭包相关的几个对象进行介绍。关于这几个对象会涉及到Python的底层实现，本文中对此不加以详述，可以参考以下文章： Python源码阅读-闭包的实现 Python闭包详解 不过，为了直观地说明闭包的实现过程（不分析底层实现），这里先简单介绍以下code对象。code对象是指代码对象，表示编译成字节的的可执行Python代码，或者字节码。它有几个比较重要的属性： co_name：函数的名称 co_nlocals: 函数使用的局部变量的个数 co_varnames: 一个包含局部变量名字的元组 co_cellvars: 是一个元组，包含嵌套的函数所引用的局部变量的名字 co_freevars: 是一个元组，保存使用了的外层作用域中的变量名 co_consts： 是一个包含字节码使用的字面量的元组 其余属性可以参考Python文档。 其中比较关键的是co_varnames和co_freevars两个属性。我们对上面的例子稍加修改： 12345678910111213141516171819&gt;&gt;&gt; def foo(): a = 1 b = 2 def bar(): return a + 1 def bar2(): return b + 2 return bar&gt;&gt;&gt; bar = foo()# 外层函数&gt;&gt;&gt; foo.func_code.co_cellvars('a', 'b')&gt;&gt;&gt; foo.func_code.co_freevars()# 内层嵌套函数&gt;&gt;&gt; bar.func_code.co_cellvars()&gt;&gt;&gt; bar.func_code.co_freevars('a',) 以上说明外层函数的code对象的co_cellvars保存了内部嵌套函数需要引用的变量的名字，而内层嵌套函数的code对象的co_freevars保存了需要引用外部函数作用域中的变量名字。具体来说，就是foo函数中嵌套了两个函数，它们都需要引用foo函数局部作用域中的变量，所以foo.func_code.co_cellvars便包含变量a和变量b的名称。而函数bar是foo的返回值，只引用了变量a，因此bar.func_code.co_freevars中便只包含变量a。 内部函数和外部函数的co_freevars、co_cellvars的对应关系，使得在函数编译过程中内部函数具有了一个闭包的特殊属性__closure__（底层中对此有相关实现）。__closure__属性是一个由cell对象组成的元组，包含了由多个作用域引用的变量。可以做以下验证： 1234567&gt;&gt;&gt; foo.__closure__ #None# 内部函数bar对变量a的引用&gt;&gt;&gt; bar.__closure__(&lt;cell at 0x00000000044F6798: int object at 0x0000000003FA4B38&gt;,)# 内部函数bar引用的变量a的值&gt;&gt;&gt; bar.__closure__[0].cell_contents1 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Python/Python中的作用域规则和闭包简析/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask中的请求上下文和应用上下文]]></title>
      <url>%2FFlask%2FFlask%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
      <content type="text"><![CDATA[在Flask中处理请求时，应用会生成一个“请求上下文”对象。整个请求的处理过程，都会在这个上下文对象中进行。这保证了请求的处理过程不被干扰。处理请求的具体代码如下： 12345def wsgi_app(self, environ, start_response): with self.request_context(environ): # with语句中生成一个`response`对象 ... return response(environ, start_response) 在Flask 0.9版本之前，应用只有“请求上下文”对象，它包含了和请求处理相关的信息。同时Flask还根据werkzeug.local模块中实现的一种数据结构LocalStack用来存储“请求上下文”对象。这在一个Flask应用运行过程剖析中有所介绍。在0.9版本中，Flask又引入了“应用上下文”的概念。本文主要Flask中的这两个“上下文”对象。 LocalStack在介绍“请求上下文”和“应用上下文”之前，我们对LocalStack简要做一个回顾。在Werkzeug库——local模块一文中，我们讲解了werkzeug.local模块中实现的三个类Local、LocalStack和LocalProxy。关于它们的概念和详细介绍，可以查看上面的文章。这里，我们用一个例子来说明Flask中使用的一种数据结构LocalStack。 123456789101112131415161718192021222324&gt;&gt;&gt; from werkzeug.local import LocalStack&gt;&gt;&gt; import threading# 创建一个`LocalStack`对象&gt;&gt;&gt; local_stack = LocalStack()# 查看local_stack中存储的信息&gt;&gt;&gt; local_stack._local.__storage__&#123;&#125;# 定义一个函数，这个函数可以向`LocalStack`中添加数据&gt;&gt;&gt; def worker(i): local_stack.push(i)# 使用3个线程运行函数`worker`&gt;&gt;&gt; for i in range(3): t = threading.Thread(target=worker, args=(i,)) t.start()# 再次查看local_stack中存储的信息&gt;&gt;&gt; local_stack._local.__storage__&#123;&lt;greenlet.greenlet at 0x4bee5a0&gt;: &#123;'stack': [2]&#125;, &lt;greenlet.greenlet at 0x4bee638&gt;: &#123;'stack': [1]&#125;, &lt;greenlet.greenlet at 0x4bee6d0&gt;: &#123;'stack': [0]&#125;&#125; 由上面的例子可以看出，存储在LocalStack中的信息以字典的形式存在：键为线程/协程的标识数值，值也是字典形式。每当有一个线程/协程上要将一个对象push进LocalStack栈中，会形成如上一个“键-值”对。这样的一种结构很好地实现了线程/协程的隔离，每个线程/协程都会根据自己线程/协程的标识数值确定存储在栈结构中的值。 LocalStack还实现了push、pop、top等方法。其中top方法永远指向栈顶的元素。栈顶的元素是指当前线程/协程中最后被推入栈中的元素，即local_stack._local.stack[-1](注意，是stack键对应的对象中最后被推入的元素)。 请求上下文Flask中所有的请求处理都在“请求上下文”中进行，在它设计之初便就有这个概念。由于0.9版本代码比较复杂，这里还是以0.1版本的代码为例进行说明。本质上这两个版本的“请求上下文”的运行原理没有变化，只是新版本增加了一些功能，这点在后面再进行解释。 请求上下文——0.1版本12345678910111213141516171819202122232425# Flask v0.1class _RequestContext(object): """The request context contains all request relevant information. It is created at the beginning of the request and pushed to the `_request_ctx_stack` and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided. """ def __init__(self, app, environ): self.app = app self.url_adapter = app.url_map.bind_to_environ(environ) self.request = app.request_class(environ) self.session = app.open_session(self.request) self.g = _RequestGlobals() self.flashes = None def __enter__(self): _request_ctx_stack.push(self) def __exit__(self, exc_type, exc_value, tb): # do not pop the request stack if we are in debug mode and an # exception happened. This will allow the debugger to still # access the request object in the interactive shell. if tb is None or not self.app.debug: _request_ctx_stack.pop() 由上面“请求上下文”的实现可知： “请求上下文”是一个上下文对象，实现了__enter__和__exit__方法。可以使用with语句构造一个上下文环境。 进入上下文环境时，_request_ctx_stack这个栈中会推入一个_RequestContext对象。这个栈结构就是上面讲的LocalStack栈。 推入栈中的_RequestContext对象有一些属性，包含了请求的的所有相关信息。例如app、request、session、g、flashes。还有一个url_adapter，这个对象可以进行URL匹配。 在with语句构造的上下文环境中可以进行请求处理。当退出上下文环境时，_request_ctx_stack这个栈会销毁刚才存储的上下文对象。 以上的运行逻辑使得请求的处理始终在一个上下文环境中，这保证了请求处理过程不被干扰，而且请求上下文对象保存在LocalStack栈中，也很好地实现了线程/协程的隔离。 以下是一个简单的例子： 1234567891011121314151617181920212223242526# example - Flask v0.1&gt;&gt;&gt; from flask import Flask, _request_ctx_stack&gt;&gt;&gt; import threading&gt;&gt;&gt; app = Flask(__name__)# 先观察_request_ctx_stack中包含的信息&gt;&gt;&gt; _request_ctx_stack._local.__storage__&#123;&#125;# 创建一个函数，用于向栈中推入请求上下文# 本例中不使用`with`语句&gt;&gt;&gt; def worker(): # 使用应用的test_request_context()方法创建请求上下文 request_context = app.test_request_context() _request_ctx_stack.push(request_context)# 创建3个进程分别执行worker方法&gt;&gt;&gt; for i in range(3): t = threading.Thread(target=worker) t.start()# 再观察_request_ctx_stack中包含的信息&gt;&gt;&gt; _request_ctx_stack._local.__storage__&#123;&lt;greenlet.greenlet at 0x5e45df0&gt;: &#123;'stack': [&lt;flask._RequestContext at 0x710c668&gt;]&#125;, &lt;greenlet.greenlet at 0x5e45e88&gt;: &#123;'stack': [&lt;flask._RequestContext at 0x7107f28&gt;]&#125;, &lt;greenlet.greenlet at 0x5e45f20&gt;: &#123;'stack': [&lt;flask._RequestContext at 0x71077f0&gt;]&#125;&#125; 上面的结果显示：_request_ctx_stack中为每一个线程创建了一个“键-值”对，每一“键-值”对中包含一个请求上下文对象。如果使用with语句，在离开上下文环境时栈中销毁存储的上下文对象信息。 请求上下文——0.9版本 在0.9版本中，Flask引入了“应用上下文”的概念，这对“请求上下文”的实现有一定的改变。这个版本的“请求上下文”也是一个上下文对象。在使用with语句进入上下文环境后，_request_ctx_stack会存储这个上下文对象。不过与0.1版本相比，有以下几点改变： 请求上下文实现了push、pop方法，这使得对于请求上下文的操作更加的灵活； 伴随着请求上下文对象的生成并存储在栈结构中，Flask还会生成一个“应用上下文”对象，而且“应用上下文”对象也会存储在另一个栈结构中去。这是两个版本最大的不同。 我们先看一下0.9版本相关的代码： 12345678910111213141516171819202122# Flask v0.9def push(self): """Binds the request context to the current context.""" top = _request_ctx_stack.top if top is not None and top.preserved: top.pop() # Before we push the request context we have to ensure that there # is an application context. app_ctx = _app_ctx_stack.top if app_ctx is None or app_ctx.app != self.app: app_ctx = self.app.app_context() app_ctx.push() self._implicit_app_ctx_stack.append(app_ctx) else: self._implicit_app_ctx_stack.append(None) _request_ctx_stack.push(self) self.session = self.app.open_session(self.request) if self.session is None: self.session = self.app.make_null_session() 我们注意到，0.9版本的“请求上下文”的pop方法中，当要将一个“请求上下文”推入_request_ctx_stack栈中的时候，会先检查另一个栈_app_ctx_stack的栈顶是否存在“应用上下文”对象或者栈顶的“应用上下文”对象的应用是否是当前应用。如果不存在或者不是当前对象，Flask会自动先生成一个“应用上下文”对象，并将其推入_app_ctx_stack中。 我们再看离开上下文时的相关代码： 12345678910111213141516171819202122232425262728293031# Flask v0.9def pop(self, exc=None): """Pops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the :meth:`~flask.Flask.teardown_request` decorator. .. versionchanged:: 0.9 Added the `exc` argument. """ app_ctx = self._implicit_app_ctx_stack.pop() clear_request = False if not self._implicit_app_ctx_stack: self.preserved = False if exc is None: exc = sys.exc_info()[1] self.app.do_teardown_request(exc) clear_request = True rv = _request_ctx_stack.pop() assert rv is self, 'Popped wrong request context. (%r instead of %r)' \ % (rv, self) # get rid of circular dependencies at the end of the request # so that we don't require the GC to be active. if clear_request: rv.request.environ['werkzeug.request'] = None # Get rid of the app as well if necessary. if app_ctx is not None: app_ctx.pop(exc) 上面代码中的细节先不讨论。注意到当要离开以上“请求上下文”环境的时候，Flask会先将“请求上下文”对象从_request_ctx_stack栈中销毁，之后会根据实际的情况确定销毁“应用上下文”对象。 以下还是以一个简单的例子进行说明： 123456789101112131415161718192021222324252627# example - Flask v0.9&gt;&gt;&gt; from flask import Flask, _request_ctx_stack, _app_ctx_stack&gt;&gt;&gt; app = Flask(__name__)# 先检查两个栈的内容&gt;&gt;&gt; _request_ctx_stack._local.__storage__&#123;&#125;&gt;&gt;&gt; _app_ctx_stack._local.__storage__&#123;&#125;# 生成一个请求上下文对象&gt;&gt;&gt; request_context = app.test_request_context()&gt;&gt;&gt; request_context.push()# 请求上下文推入栈后，再次查看两个栈的内容&gt;&gt;&gt; _request_ctx_stack._local.__storage__&#123;&lt;greenlet.greenlet at 0x6eb32a8&gt;: &#123;'stack': [&lt;RequestContext 'http://localhost/' [GET] of __main__&gt;]&#125;&#125;&gt;&gt;&gt; _app_ctx_stack._local.__storage__&#123;&lt;greenlet.greenlet at 0x6eb32a8&gt;: &#123;'stack': [&lt;flask.ctx.AppContext at 0x5c96a58&gt;]&#125;&#125;&gt;&gt;&gt; request_context.pop()# 销毁请求上下文时，再次查看两个栈的内容&gt;&gt;&gt; _request_ctx_stack._local.__storage__&#123;&#125;&gt;&gt;&gt; _app_ctx_stack._local.__storage__&#123;&#125; 应用上下文上部分中简单介绍了“应用上下文”和“请求上下文”的关系。那什么是“应用上下文”呢？我们先看一下它的类： 123456789101112131415161718192021222324252627282930313233343536373839class AppContext(object): """The application context binds an application object implicitly to the current thread or greenlet, similar to how the :class:`RequestContext` binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context. """ def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) # Like request context, app contexts can be pushed multiple times # but there a basic "refcount" is enough to track them. self._refcnt = 0 def push(self): """Binds the app context to the current context.""" self._refcnt += 1 _app_ctx_stack.push(self) def pop(self, exc=None): """Pops the app context.""" self._refcnt -= 1 if self._refcnt &lt;= 0: if exc is None: exc = sys.exc_info()[1] self.app.do_teardown_appcontext(exc) rv = _app_ctx_stack.pop() assert rv is self, 'Popped wrong app context. (%r instead of %r)' \ % (rv, self) def __enter__(self): self.push() return self def __exit__(self, exc_type, exc_value, tb): self.pop(exc_value) 由以上代码可以看出：“应用上下文”也是一个上下文对象，可以使用with语句构造一个上下文环境，它也实现了push、pop等方法。“应用上下文”的构造函数也和“请求上下文”类似，都有app、url_adapter等属性。“应用上下文”存在的一个主要功能就是确定请求所在的应用。 然而，以上的论述却又让人产生这样的疑问：既然“请求上下文”中也包含app等和当前应用相关的信息，那么只要调用_request_ctx_stack.top.app或者魔法current_app就可以确定请求所在的应用了，那为什么还需要“应用上下文”对象呢？对于单应用单请求来说，使用“请求上下文”确实就可以了。然而，Flask的设计理念之一就是多应用的支持。当在一个应用的请求上下文环境中，需要嵌套处理另一个应用的相关操作时，“请求上下文”显然就不能很好地解决问题了。如何让请求找到“正确”的应用呢？我们可能会想到，可以再增加一个请求上下文环境，并将其推入_request_ctx_stack栈中。由于两个上下文环境的运行是独立的，不会相互干扰，所以通过调用_request_ctx_stack.top.app或者魔法current_app也可以获得当前上下文环境正在处理哪个应用。这种办法在一定程度上可行，但是如果对于第二个应用的处理不涉及到相关请求，那也就无从谈起“请求上下文”。 为了应对这个问题，Flask中将应用相关的信息单独拿出来，形成一个“应用上下文”对象。这个对象可以和“请求上下文”一起使用，也可以单独拿出来使用。不过有一点需要注意的是：在创建“请求上下文”时一定要创建一个“应用上下文”对象。有了“应用上下文”对象，便可以很容易地确定当前处理哪个应用，这就是魔法current_app。在0.1版本中，current_app是对_request_ctx_stack.top.app的引用，而在0.9版本中current_app是对_app_ctx_stack.top.app的引用。 下面以一个多应用的例子进行说明： 1234567891011121314151617181920212223242526272829303132333435363738# example - Flask v0.9&gt;&gt;&gt; from flask import Flask, _request_ctx_stack, _app_ctx_stack# 创建两个Flask应用&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; app2 = Flask(__name__)# 先查看两个栈中的内容&gt;&gt;&gt; _request_ctx_stack._local.__storage__&#123;&#125;&gt;&gt;&gt; _app_ctx_stack._local.__storage__&#123;&#125;# 构建一个app的请求上下文环境，在这个环境中运行app2的相关操作&gt;&gt;&gt; with app.test_request_context(): print "Enter app's Request Context:" print _request_ctx_stack._local.__storage__ print _app_ctx_stack._local.__storage__ print with app2.app_context(): print "Enter app2's App Context:" print _request_ctx_stack._local.__storage__ print _app_ctx_stack._local.__storage__ print # do something print "Exit app2's App Context:" print _request_ctx_stack._local.__storage__ print _app_ctx_stack._local.__storage__ print# ResultEnter app's Request Context:&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;'stack': [&lt;RequestContext 'http://localhost/' [GET] of __main__&gt;]&#125;&#125;&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x0000000005DD0DD8&gt;]&#125;&#125;Enter app2's App Context:&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;'stack': [&lt;RequestContext 'http://localhost/' [GET] of __main__&gt;]&#125;&#125;&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x0000000005DD0DD8&gt;, &lt;flask.ctx.AppContext object at 0x0000000007313198&gt;]&#125;&#125;Exit app2's App Context&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;'stack': [&lt;RequestContext 'http://localhost/' [GET] of __main__&gt;]&#125;&#125;&#123;&lt;greenlet.greenlet object at 0x000000000727A178&gt;: &#123;'stack': [&lt;flask.ctx.AppContext object at 0x0000000005DD0DD8&gt;]&#125;&#125; 在以上的例子中： 我们首先创建了两个Flask应用app和app2； 接着我们构建了一个app的请求上下文环境。当进入这个环境中时，这时查看两个栈的内容，发现两个栈中已经有了当前请求的请求上下文对象和应用上下文对象。并且栈顶的元素都是app的请求上下文和应用上下文； 之后，我们再在这个环境中嵌套app2的应用上下文。当进入app2的应用上下文环境时，两个上下文环境便隔离开来，此时再查看两个栈的内容，发现_app_ctx_stack中推入了app2的应用上下文对象，并且栈顶指向它。这时在app2的应用上下文环境中，current_app便会一直指向app2； 当离开app2的应用上下文环境，_app_ctx_stack栈便会销毁app2的应用上下文对象。这时查看两个栈的内容，发现两个栈中只有app的请求的请求上下文对象和应用上下文对象。 最后，离开app的请求上下文环境后，两个栈便会销毁app的请求的请求上下文对象和应用上下文对象，栈为空。 与上下文对象有关的“全局变量”在Flask中，为了更加方便地处理一些变量，特地提出了“全局变量”的概念。这些全局变量有： 123456789101112131415161718192021# Flask v0.9_request_ctx_stack = LocalStack()_app_ctx_stack = LocalStack()current_app = LocalProxy(_find_app)request = LocalProxy(partial(_lookup_object, 'request'))session = LocalProxy(partial(_lookup_object, 'session'))g = LocalProxy(partial(_lookup_object, 'g'))# 辅助函数def _lookup_object(name): top = _request_ctx_stack.top if top is None: raise RuntimeError('working outside of request context') return getattr(top, name)def _find_app(): top = _app_ctx_stack.top if top is None: raise RuntimeError('working outside of application context') return top.app 可以看出，Flask中使用的一些“全局变量”，包括current_app、request、session、g等都来自于上下文对象。其中current_app一直指向_app_ctx_stack栈顶的“应用上下文”对象，是对当前应用的引用。而request、session、g等一直指向_request_ctx_stack栈顶的“请求上下文”对象，分别引用请求上下文的request、session和g。不过，从 Flask 0.10 起，对象 g 存储在应用上下文中而不再是请求上下文中。 另外一个问题，在形成这些“全局变量”的时候，使用了werkzeug.local模块的LocalProxy类。之所以要用该类，主要是为了动态地实现对栈顶元素的引用。如果不使用这个类，在生成上述“全局变量”的时候，它们因为指向栈顶元素，而栈顶元素此时为None，所以这些变量也会被设置为None常量。后续即使有上下文对象被推入栈中，相应的“全局变量”也不会发生改变。为了动态地实现对栈顶元素的引用，这里必须使用werkzeug.local模块的LocalProxy类。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Flask中的请求上下文和应用上下文/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask中的蓝图管理]]></title>
      <url>%2FFlask%2FFlask%E4%B8%AD%E7%9A%84%E8%93%9D%E5%9B%BE%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[在Flask中模块化应用的实现一文中，我们曾分析过Flask 0.2版本中的Module类。这个类能够实现Flask应用的多模块化管理。在0.7版本中，Flask重新设计了模块化管理的内容，提出了“蓝图”的概念，用来取代Module的功能。 什么是“蓝图”官方文档中对“蓝图”的概念是这样描述的： Flask uses a concept of blueprints for making application components and supporting common patterns within an application or across applications. Blueprints can greatly simplify how large applications work and provide a central means for Flask extensions to register operations on applications. A Blueprint object works similarly to a Flask application object, but it is not actually an application. Rather it is a blueprint of how to construct or extend an application. 按照以上的描述，可以看出“蓝图”系统在Flask应用的组件化和扩展提供了很大的便利。“组件化”是指可以在Flask层上将一个Flask应用进行“分割”，实现模块化管理，这极大地简化了构建大型应用的流程，也使得应用的维护变得更加容易。另外，“蓝图”还提供了一种Flask扩展在应用上注册操作的核心方法。 “蓝图”和一个Flask应用对象很相似，但是并不是一个Flask应用对象。它是可以注册到Flask应用上的一系列操作（对于此的理解，后文会详细讲到）。使用“蓝图”，可以实现以下的一些功能： 将Flask应用“分割”为一系列“蓝图”的集合，简化了大型应用工作的方式； 在Flask应用上，以 URL 前缀和或子域名注册一个蓝图。可以以不同的URL多次注册一个蓝图； 通过蓝图提供模板过滤器、静态文件、模板和其它功能。 创建“蓝图”对象时发生了什么“蓝图”和Flask应用的工作方式非常相似。Flask中的“蓝图”系统能够实现很多“蓝图”对象在应用层上的管理，这些“蓝图”对象可以共享应用配置。这意味着“蓝图”应该和Flask应用有一样的运行逻辑，这样一旦蓝图注册到应用上，就可以完全像Flask应用一样工作。 。在Flask应用中有一些属性，它们以字典的形式用来存放很多装饰器运行的结果。例如：view_functions这个字典通常存放route装饰器装饰的视图函数，可以用来进行URL匹配；before_request_functions字典会存放before_request装饰器装饰的视图函数，当正式处理请求前会先运行这个字典中的函数······为了实现和Flask应用相同的请求处理逻辑，“蓝图”对象也设计了同样的装饰器函数，这些函数都是一些“匿名函数”，只要传递一个参数，就可以将本蓝图上的一些操作映射到Flask应用上去。 例如：before_request装饰器 12345678def before_request(self, f): """Like :meth:`Flask.before_request` but for a blueprint. This function is only executed before each request that is handled by a function of that blueprint. """ self.record_once(lambda s: s.app.before_request_funcs .setdefault(self.name, []).append(f)) return f 上面的代码中，只要给这个装饰器传递参数s，那么这个装饰器就会将装饰的函数添加到Flask应用的before_request_functions字典当中，并且和该“蓝图”的名字对应起来。这样就可以实现该函数在Flask应用中可用。 由于“蓝图”的创建过程和Flask应用的创建过程是分离的，所以在“蓝图”中使用装饰器不会立即对应用产生效果。“蓝图”中装饰器函数的返回值会经过record_once方法存储在“蓝图”对象的deferred_functions列表中，这为“蓝图”对象的注册提供了一个接口：只要在注册“蓝图”时执行deferred_functions列表中的函数即可。 以下是一个简单的例子： 123456789101112131415161718192021# blueprint&gt;&gt;&gt; from flask import Blueprint&gt;&gt;&gt; blog = Blueprint('blog', __name__, static_folder='static', template_folder='templates')&gt;&gt;&gt; @blog.route('/') def index(): return "This is blog home page."&gt;&gt;&gt; @blog.before_request def before_request(): return "This is before_request function."&gt;&gt;&gt; @blog.after_request def after_request(): return "This is after_request function."&gt;&gt;&gt; @blog.after_app_request def after_app_request(): return "This is after_app_request function." 上面的例子中： 首先我们创建了一个“蓝图”对象blog。创建“蓝图”对象时，必须至少传递前两个参数：name和import_name。也可以传递static_folder、template_folder、url_prefix等参数，url_prefix参数也可以在注册蓝图时传入。 之后，我们为blog增加了四条视图函数，每个函数由蓝图的装饰器装饰。此时，我们看一下“蓝图”对象的deferred_functions中有什么： 123456&gt;&gt;&gt; blog.deferred_functions[&lt;function flask.blueprints.&lt;lambda&gt;&gt;, &lt;function flask.blueprints.&lt;lambda&gt;&gt;, &lt;function flask.blueprints.&lt;lambda&gt;&gt;, &lt;function flask.blueprints.&lt;lambda&gt;&gt;] 可以看出，此时“蓝图”对象的deferred_functions中已经包含了四个匿名函数，分别对应上面例子中的四个视图函数。一旦“蓝图”被注册到应用上，会执行这四个函数。 注册“蓝图”Flask应用和“蓝图”中都有注册“蓝图”的接口。 Flask应用 中的接口是： 12345678910111213141516def register_blueprint(self, blueprint, **options): """Registers a blueprint on the application. .. versionadded:: 0.7 """ first_registration = False if blueprint.name in self.blueprints: assert self.blueprints[blueprint.name] is blueprint, \ 'A blueprint\'s name collision ocurred between %r and ' \ '%r. Both share the same name "%s". Blueprints that ' \ 'are created on the fly need unique names.' % \ (blueprint, self.blueprints[blueprint.name], blueprint.name) else: self.blueprints[blueprint.name] = blueprint first_registration = True blueprint.register(self, options, first_registration) 这个方法首先会对“蓝图”进行检查，如果已经注册，则会出现一条assert语句。否则，就会调用“蓝图”对象的register方法进行注册。 蓝图对象 中的接口是： 12345678910111213141516def register(self, app, options, first_registration=False): """Called by :meth:`Flask.register_blueprint` to register a blueprint on the application. This can be overridden to customize the register behavior. Keyword arguments from :func:`~flask.Flask.register_blueprint` are directly forwarded to this method in the `options` dictionary. """ self._got_registered_once = True state = self.make_setup_state(app, options, first_registration) if self.has_static_folder: state.add_url_rule(self.static_url_path + '/&lt;path:filename&gt;', view_func=self.send_static_file, endpoint='static') for deferred in self.deferred_functions: deferred(state) 蓝图对象中的register方法首先会生成一个BlueprintSetupState对象，这个对象将当前应用和当前蓝图的相关信息进行关联，还将作为参数传递到蓝图对象deferred_functions列表中的每一个函数。这样，蓝图中的相关操作就会映射到当前应用当中。 还是以上面的例子为例： 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; from flask import Flask&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; app.url_mapMap([&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;])&gt;&gt;&gt; app.blueprints&#123;&#125;&gt;&gt;&gt; app.before_request_funcs&#123;&#125;&gt;&gt;&gt; app.after_request_funcs&#123;&#125;&gt;&gt;&gt; app.register_blueprint(blog, url_prefix='/blog')&gt;&gt;&gt; app.url_mapMap([&lt;Rule '/blog/' (HEAD, OPTIONS, GET) -&gt; blog.index&gt;, &lt;Rule '/blog/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; blog.static&gt;, &lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt; ])&gt;&gt;&gt; app.blueprints&#123;'blog': &lt;flask.blueprints.Blueprint at 0x896e7f0&gt;&#125;&gt;&gt;&gt; app.before_request_funcs&#123;'blog': [&lt;function __main__.before_request&gt;]&#125;&gt;&gt;&gt; app.after_request_funcs&#123;None: [&lt;function __main__.after_app_request&gt;], 'blog': [&lt;function __main__.after_request&gt;]&#125; 经过上面的例子，可以发现“蓝图”对象注册到Flask应用时，会在Flask应用对应的地方增加“蓝图”对象的相关信息。例如，blog对象中有一个before_request装饰器，注册成功后，在app.before_request_funcs增加了该信息，并且以蓝图名作为键进行区分。blog对象中还有一个route装饰器，它为蓝图增加了一条URL规则，最终会在Flask应用的url_map中出现。由于在创建蓝图时我们增加了static_folder参数，所以在url_map中我们还可以看到&#39;/blog/static/&lt;filename&gt;&#39;这样的URL规则。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Flask中的蓝图管理/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask中模块化应用的实现]]></title>
      <url>%2FFlask%2FFlask%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[Flask是一个轻量级的Web框架。虽然是轻量级的，但是对于组件一个大型的、模块化应用也是能够实现的，“蓝图”就是这样一种实现。对于模块化应用的实现，在Flask 0.2版本中进行了设计。本文暂时不对“蓝图”做详细的介绍，而是先从0.2版本中的Module类的实现讲起。其实，“蓝图”的实现和Module类的实现很相似。 为什么实现模块化应用对于大型应用而言，随着功能的不断增加，整个应用的规模也会扩大。按照一定的规则将应用的不同部分进行模块化，不仅能够使整个应用逻辑清晰，也易于维护。例如，在Flask中，你也许想像如下构建一个简单的项目： 123456/myapplication /__init__.py /views /__init__.py /admin.py /frontend.py 以上目录结构中，我们将之前的Flask单文件修改成了一个应用包，所有的视图函数都在views下，并且按照功能分为了admin和frontend两个部分。为了实现这种模块化应用的构建，在0.2版本中Flask实现了Module类。这个类实例可以通过注册的方式，在Flask应用创建后添加进应用。 Module类实现了一系列的方法： route(rule, **options) add_url_rule(rule, endpoint, view_func=None, **options) before_request(f) before_app_request(f) after_request(f) after_app_request(f) context_processor(f) app_context_processor(f) _record(func) 以上方法除了add_url_rule和_record外，都可以作为装饰器在自己的模块中使用，这些装饰器都返回一个函数。通过调用_record方法，可以将装饰器返回的函数放到_register_events中。当Flask应用创建之后，通过运行_register_events列表中的函数，可以将这个模块注册到应用中去。 Flask应用怎么注册一个Module以下我们以一个例子来说明Flask应用怎么注册一个Module。 1. 项目结构这个简单的例子项目结构如下： 1234567/myapplication /__init__.py /app.py /views /__init__.py /admin.py /blog.py admin.py和blog.py两个模块的代码如下： 123456789101112# admin.pyfrom flask import Moduleadmin = Module(__name__)@admin.route('/')def index(): return "This is admin page!"@admin.route('/profile')def profile(): return "This is profile page." 123456789101112# blog.pyfrom flask import Moduleblog = Module(__name__)@blog.route('/')def index(): return "This is my blog!"@blog.route('/article/&lt;int:id&gt;')def article(id): return "The article id is %d." % id 以上两个模块中，我们首先分别创建了一个Module类，然后像写一般的视图函数一样，为每个模块增加一些规则。之后，可以在创建Flask应用的时候将这些模块引入，就可以注册了。 1234567891011121314151617# app.pyfrom flask import Flaskfrom views.admin import adminfrom views.blog import blogapp = Flask(__name__)@app.route('/')def index(): return "This is my app."app.register_module(blog, url_prefix='/blog')app.register_module(admin, url_prefix='/admin')if __name__ == '__main__': from werkzeug.serving import run_simple run_simple('localhost', 5000, app) 在app.py中： 我们首先引入了admin和blog两个Module对象； 之后，我们创建了一个Flask应用app，并且为这个应用增加了一个视图函数； 为了注册模块，我们调用了应用的register_module方法； 最后，从werkzeug.serving中我们调用run_simple方法，用来创建一个本地的服务器用于测试这个Flask应用。 根据以上的步骤，我们就可以测试这个应用。分别以/blog和/admin为URL前缀，就可以访问blog和admin两个模块了。 2. 注册Module时发生了什么根据上面的例子，只要简单的调用Flask应用的register_module方法，就可以注册一个Module了。关于register_module方法的代码如下： 12345678910def register_module(self, module, **options): """Registers a module with this application. The keyword argument of this function are the same as the ones for the constructor of the :class:`Module` class and will override the values of the module if provided. """ options.setdefault('url_prefix', module.url_prefix) state = _ModuleSetupState(self, **options) for func in module._register_events: func(state) 通过以上代码可以发现： 可以通过增加url_prefix来区分不同的Module，这在app注册admin和blog时我们已经看到了； 在注册时，我们创建了一个_ModuleSetupState的类，这个类接收Flask应用和一些参数生成一个state实例。这个实例反映了当前Flask应用的状态。 前面在讲到Module类的时候，我们讲到Module未注册时会将自己模块的一些功能实现都放在_register_events列表中，这些功能实现都是函数形式。当需要将模块注册到某一应用上时，只需要传递关于这个应用信息的参数即可，即就是上面的state实例。这样，通过运行函数，可以讲一些属性绑定到当前应用上去。 以上面例子中不同模块的URL绑定来讲，通过注册，应用app现形成了如下的URL“地图”： 12345678910111213141516171819202122232425&gt;&gt;&gt; app.url_mapMap([&lt;Rule '/admin/profile' (HEAD, GET) -&gt; admin.profile&gt;, &lt;Rule '/admin/' (HEAD, GET) -&gt; admin.index&gt;, &lt;Rule '/blog/' (HEAD, GET) -&gt; blog.index&gt;, &lt;Rule '/' (HEAD, GET) -&gt; index&gt;, &lt;Rule '/blog/article/&lt;id&gt;' (HEAD, GET) -&gt; blog.article&gt;, &lt;Rule '/static/&lt;filename&gt;' (HEAD, GET) -&gt; static&gt;] )&gt;&gt;&gt; app.url_map._rules_by_endpoint&#123;'admin.index': [&lt;Rule '/admin/' (HEAD, GET) -&gt; admin.index&gt;], 'admin.profile': [&lt;Rule '/admin/profile' (HEAD, GET) -&gt; admin.profile&gt;], 'blog.article': [&lt;Rule '/blog/article/&lt;id&gt;' (HEAD, GET) -&gt; blog.article&gt;], 'blog.index': [&lt;Rule '/blog/' (HEAD, GET) -&gt; blog.index&gt;], 'index': [&lt;Rule '/' (HEAD, GET) -&gt; index&gt;], 'static': [&lt;Rule '/static/&lt;filename&gt;' (HEAD, GET) -&gt; static&gt;]&#125;&gt;&gt;&gt; app.view_functions&#123;'admin.index': &lt;function views.admin.index&gt;, 'admin.profile': &lt;function views.admin.profile&gt;, 'blog.article': &lt;function views.blog.article&gt;, 'blog.index': &lt;function views.blog.index&gt;, 'index': &lt;function __main__.index&gt;&#125; 这样，就可以把不同模块的URL规则放在一起，并在endpoint和视图函数之间形成对应关系。关于Flask应用中URL处理，可以参考：Flask应用中的URL处理。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Flask中模块化应用的实现/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask应用中的URL处理]]></title>
      <url>%2FFlask%2FFlask%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84URL%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[在文章：一个Flask应用运行过程剖析中，在一个上下文环境中可以处理请求。如果不考虑在处理请求前后做的一些操作，Flask源码中真正处理请求的是dispatch_request()方法。其源码如下： 12345678910111213141516171819def dispatch_request(self): """Does the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call :func:`make_response`. """ try: endpoint, values = self.match_request() return self.view_functions[endpoint](**values) except HTTPException, e: handler = self.error_handlers.get(e.code) if handler is None: return e return handler(e) except Exception, e: handler = self.error_handlers.get(500) if self.debug or handler is None: raise return handler(e) 从上面的源码中可以看到，dispatch_request()方法做了如下的工作： 对请求的URL进行匹配； 如果URL可以匹配，则返回相对应视图函数的结果； 如果不可以匹配，则进行错误处理。 对于错误的处理，本文暂不做介绍。本文主要对Flask应用的URL模式以及请求处理过程中的URL匹配进行剖析。 Flask应用的url_mapFlask应用实例化的时候，会为应用增添一个url_map属性。这个属性是一个Map类，这个类在werkzeug.routing模块中定义，其主要的功能是为了给应用增加一些URL规则，这些URL规则形成一个Map实例的过程中会生成对应的正则表达式，可以进行URL匹配。相关的概念和内容可以参考：Werkzeug库——routing模块。 在Flask源码中，它通过两个方法可以很方便地定制应用的URL。这两个方法是：route装饰器和add_url_rule方法。 1. add_url_rule1234def add_url_rule(self, rule, endpoint, **options): options['endpoint'] = endpoint options.setdefault('methods', ('GET',)) self.url_map.add(Rule(rule, **options)) add_url_rule方法很简单，只要向其传递一条URL规则rule和一个endpoint即可。endpoint一般为和这条URL相关的视图函数的名字，这样处理就可以将URL和视图函数关联起来。除此之外，还可以传递一些关键字参数。调用该方法后，会调用Map实例的add方法，它会将URL规则添加进Map实例中。 2. route装饰器为了更加方便、优雅地写应用的URL，Flask实现了一个route装饰器。 123456def route(self, rule, **options): def decorator(f): self.add_url_rule(rule, f.__name__, **options) self.view_functions[f.__name__] = f return f return decorator route装饰器会装饰一个视图函数。经route装饰的视图函数首先会调用add_url_rule方法，将装饰器中的URL规则添加进Map实例中，视图函数的名字会作为endpoint进行传递。然后在该应用的view_functions中增加endpoint和视图函数的对应关系。这种对应关系可以在请求成功时方便地调用对应的视图函数。 3. 一个简单的例子我们用一个简单的例子来说明以上过程的实现： 1234567891011&gt;&gt;&gt; from flask import Flask&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route('/') def index(): return "Hello, World!"&gt;&gt;&gt; @app.route('/&lt;username&gt;') def user(username): return "Hello, %s" % username&gt;&gt;&gt; @app.route('/page/&lt;int:id&gt;') def page(id): return "This is page %d" % id 以上代码，我们创建了一个Flask应用app，并且通过route装饰器的形式为app增加了3条URL规则。 首先： 我们看一下Flask应用的url_map长啥样： 12345678&gt;&gt;&gt; url_map = app.url_map&gt;&gt;&gt; url_mapMap([&lt;Rule '/' (HEAD, GET) -&gt; index&gt;, &lt;Rule '/static/&lt;filename&gt;' -&gt; static&gt;, &lt;Rule '/page/&lt;id&gt;' (HEAD, GET) -&gt; page&gt;, &lt;Rule '/&lt;username&gt;' (HEAD, GET) -&gt; user&gt; ]) 可以看到，url_map是一个Map实例，这个实例中包含4个Rule实例，分别对应4条URL规则，其中/static/&lt;filename&gt;在Flask应用实例化时会自动添加，其余3条是用户创建的。整个Map类便构成了Flask应用app的URL“地图”，可以用作URL匹配的依据。 接下来： 我们看一下url_map中的一个属性：_rules_by_endpoint： 12345678&gt;&gt;&gt; rules_by_endpoint = url_map._rules_by_endpoint&gt;&gt;&gt; rules_by_endpoint&#123;'index': [&lt;Rule '/' (HEAD, GET) -&gt; index&gt;], 'page': [&lt;Rule '/page/&lt;id&gt;' (HEAD, GET) -&gt; page&gt;], 'static': [&lt;Rule '/static/&lt;filename&gt;' -&gt; static&gt;], 'user': [&lt;Rule '/&lt;username&gt;' (HEAD, GET) -&gt; user&gt;]&#125; 可以看出，_rules_by_endpoint属性是一个字典，反映了endpoint和URL规则的对应关系。由于用route装饰器创建URL规则时，会将视图函数的名字作为endpoint进行传递，所以以上字典的内容也反映了视图函数和URL规则的对应关系。 再接下来： 我们看一下Flask应用的view_functions： 1234567&gt;&gt;&gt; view_functions = app.view_functions&gt;&gt;&gt; view_functions&#123;'index': &lt;function __main__.index&gt;, 'page': &lt;function __main__.page&gt;, 'user': &lt;function __main__.user&gt;&#125; 在用route装饰器创建URL规则时，它还会做一件事情：self.view_functions[f.__name__] = f。这样做是将函数名和视图函数的对应关系放在Flask应用的view_functions。由于Map实例中存储了函数名和URL规则的对应关系，这样只要在匹配URL规则时，如果匹配成功，只要返回一个函数名，那么便可以在view_functions中运行对应的视图函数。 最后： 我们看一下URL如何和Map实例中的URL规则进行匹配。我们以/page/&lt;int:id&gt;这条规则为例： 123456789&gt;&gt;&gt; rule = url_map._rules[2]&gt;&gt;&gt; rule&lt;Rule '/page/&lt;id&gt;' (HEAD, GET) -&gt; page&gt;&gt;&gt;&gt; rule._regexre.compile(ur'^\|\/page\/(?P&lt;id&gt;\d+)$', re.UNICODE)&gt;&gt;&gt; rule._regex.patternu'^\\|\\/page\\/(?P&lt;id&gt;\\d+)$' 可以看到，在将一条URL规则的实例Rule添加进Map实例的时候，会为这个Rule生成一个正则表达式的属性_regex。这样当这个Flask应用处理请求时，实际上会将请求中的url和Flask应用中每一条URL规则的正则表达式进行匹配。如果匹配成功，则会返回endpoint和一些参数，返回的endpoint可以用来在view_functions找到对应的视图函数，返回的参数可以传递给视图函数。具体的过程就是： 12345try: # match_request()可以进行URL匹配 endpoint, values = self.match_request() return self.view_functions[endpoint](**values) ... 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Flask应用中的URL处理/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flask框架简介]]></title>
      <url>%2FFlask%2FFlask%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[Flask是当下流行的Web框架，它是用Python实现的。Flask显著的特点是：它是一个“微”框架。”微”意味着Flask旨在保持核心的简单，但同时又易于扩展。默认情况下，Flask 不包含数据库抽象层、表单验证，或是其它任何已有多种库可以胜任的功能。然而，Flask 支持用扩展来给应用添加这些功能。众多的扩展提供了数据库集成、表单验证、上传处理、各种各样的开放认证技术等功能。Flask的这些特性，使得它在Web开发方面变得非常流行。 文章目录本板块将对Flask的运行机制进行分析和探讨，同时还将包括使用Flask过程中的心得体会、疑问等等。 一个Flask应用运行过程剖析 Flask应用中的URL处理 Flask中模块化应用的实现 Flask中的蓝图管理 Flask中的请求上下文和应用上下文 后续将继续更新······ 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Flask框架简介/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个Flask应用运行过程剖析]]></title>
      <url>%2FFlask%2F%E4%B8%80%E4%B8%AAFlask%E5%BA%94%E7%94%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%89%96%E6%9E%90%2F</url>
      <content type="text"><![CDATA[相信很多初学Flask的同学（包括我自己），在阅读官方文档或者Flask的学习资料时，对于它的认识是从以下的一段代码开始的： 12345678910from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return "Hello World!"if __name__ == '__main__': app.run() 运行如上代码，在浏览器中访问http://localhost:5000/，便可以看到Hello World!出现了。这是一个很简单的Flask的应用。 然而，这段代码怎么运行起来的呢？一个Flask应用运转的背后又有哪些逻辑呢？如果你只关心Web应用，那对这些问题不关注也可以，但从整个Web编程的角度来看，这些问题非常有意义。本文就主要针对一个Flask应用的运行过程进行简要分析，后续文章还会对Flask框架的一些具体问题进行分析。 为了分析方便，本文采用 Flask 0.1版本 的源码进行相关问题的探索。 一些准备知识在正式分析Flask之前，有一些准备知识需要先了解一下： 使用Flask框架开发的属于Web应用。由于Python使用WSGI网关，所以这个应用也可以叫WSGI应用； 服务器、Web应用的设计应该遵循网关接口的一些规范。对于WSGI网关，要求Web应用实现一个函数或者一个可调用对象webapp(environ, start_response)。服务器或网关中要定义start_response函数并且调用Web应用。关于这部分的内容可以参考：wsgiref包——符合WSGI标准的Web服务实现（一）。 Flask依赖于底层库werkzeug。相关内容可以参考：Werkzeug库简介。 本文暂时不对服务器或网关的具体内容进行介绍，只需对服务器、网关、Web应用之间有怎样的关系，以及它们之间如何调用有一个了解即可。 一个Flask应用运行的过程1. 实例化一个Flask应用使用app = Flask(__name__)，可以实例化一个Flask应用。实例化的Flask应用有一些要点或特性需要注意一下： 对于请求和响应的处理，Flask使用werkzeug库中的Request类和Response类。对于这两个类的相关内容可以参考：Werkzeug库——wrappers模块。 对于URL模式的处理，Flask应用使用werkzeug库中的Map类和Rule类，每一个URL模式对应一个Rule实例，这些Rule实例最终会作为参数传递给Map类构造包含所有URL模式的一个“地图”。这个地图可以用来匹配请求中的URL信息，关于Map类和Rule类的相关知识可以参考：Werkzeug库——routing模块。 当实例化一个Flask应用app（这个应用的名字可以随便定义）之后，对于如何添加URL模式，Flask采取了一种更加优雅的模式，对于这点可以和Django的做法进行比较。Flask采取装饰器的方法，将URL规则和视图函数结合在一起写，其中主要的函数是route。在上面例子中： 123@app.route('/')def index(): pass 这样写视图函数，会将&#39;/&#39;这条URL规则和视图函数index()联系起来，并且会形成一个Rule实例，再添加进Map实例中去。当访问&#39;/&#39;时，会执行index()。关于Flask匹配URL的内容，可以参考后续文章。 实例化Flask应用时，会创造一个Jinja环境，这是Flask自带的一种模板引擎。可以查看Jinja文档，这里先暂时不做相关介绍。 实例化的Flask应用是一个可调用对象。在前面讲到，Web应用要遵循WSGI规范，就要实现一个函数或者一个可调用对象webapp(environ, start_response)，以方便服务器或网关调用。Flask应用通过__call__(environ, start_response)方法可以让它被服务器或网关调用。 123def __call__(self, environ, start_response): """Shortcut for :attr:`wsgi_app`""" return self.wsgi_app(environ, start_response) 注意到调用该方法会执行wsgi_app(environ, start_response)方法，之所以这样设计是为了在应用正式处理请求之前，可以加载一些“中间件”,以此改变Flask应用的相关特性。对于这一点后续会详细分析。 Flask应用还有一些其他的属性或方法，用于整个请求和响应过程。 2.调用Flask应用时会发生什么上面部分分析了实例化的Flask应用长什么样子。当一个完整的Flask应用实例化后，可以通过调用app.run()方法运行这个应用。 Flask应用的run()方法会调用werkzeug.serving模块中的run_simple方法。这个方法会创建一个本地的测试服务器，并且在这个服务器中运行Flask应用。关于服务器的创建这里不做说明，可以查看werkzeug.serving模块的有关文档。 当服务器开始调用Flask应用后，便会触发Flask应用的__call__(environ, start_response)方法。其中environ由服务器产生，start_response在服务器中定义。 上面我们分析到当Flask应用被调用时会执行wsgi_app(environ, start_response)方法。可以看出，wsgi_app是真正被调用的WSGI应用，之所以这样设计，就是为了在应用正式处理请求之前，wsgi_app可以被一些“中间件”装饰，以便先行处理一些操作。为了便于理解，这里先举两个例子进行说明。 例子一： 中间件SharedDataMiddleware中间件SharedDataMiddleware是werkzeug.wsgi模块中的一个类。该类可以为Web应用提供静态内容的支持。例如： 123456import osfrom werkzeug.wsgi import SharedDataMiddlewareapp = SharedDataMiddleware(app, &#123; '/shared': os.path.join(os.path.dirname(__file__), 'shared')&#125;) Flask应用通过以上的代码，app便会成为一个SharedDataMiddleware实例，之后便可以在http://example.com/shared/中访问shared文件夹下的内容。 对于中间件SharedDataMiddleware，Flask应用在初始实例化的时候便有所应用。其中有这样一段代码： 123self.wsgi_app = SharedDataMiddleware(self.wsgi_app, &#123; self.static_path: target &#125;) 这段代码显然会将wsgi_app变成一个SharedDataMiddleware对象，这个对象为Flask应用提供一个静态文件夹/static。这样，当整个Flask应用被调用时，self.wsgi_app(environ, start_response)会执行。由于此时self.wsgi_app是一个SharedDataMiddleware对象，所以会先触发SharedDataMiddleware对象的__call__(environ, start_response)方法。如果此时的请示是要访问/static这个文件夹，SharedDataMiddleware对象会直接返回响应；如果不是，则才会调用Flask应用的wsgi_app(environ.start_response)方法继续处理请求。 例子二： 中间件DispatcherMiddleware中间件DispatcherMiddleware也是werkzeug.wsgi模块中的一个类。这个类可以讲不同的应用“合并”起来。以下是一个使用中间件DispatcherMiddleware的例子。 123456789101112131415161718192021222324252627from flask import Flaskfrom werkzeug import DispatcherMiddlewareapp1 = Flask(__name__)app2 = Flask(__name__)app = Flask(__name__)@app1.route('/')def index(): return "This is app1!"@app2.route('/')def index(): return "This is app2!"@app.route('/')def index(): return "This is app!"app = DispatcherMiddleware(app, &#123; '/app1': app1, '/app2': app2 &#125;)if __name__ == '__main__': from werkzeug.serving import run_simple run_simple('localhost', 5000, app) 在上面的例子中，我们首先创建了三个不同的Flask应用，并为每个应用创建了一个视图函数。但是，我们使用了DispatcherMiddleware，将app1、app2和app合并起来。这样，此时的app便成为一个DispatcherMiddleware对象。 当在服务器中调用app时，由于它是一个DispatcherMiddleware对象，所以首先会触发它的__call__(environ, start_response)方法。然后根据请求URL中的信息来确定要调用哪个应用。例如： 如果访问/，则会触发app(environ, start_response)（注意： 此时app是一个Flask对象），进而处理要访问app的请求； 如果访问/app1，则会触发app1(environ, start_response)，进而处理要访问app1的请求。访问/app2同理。 3. 和请求处理相关的上下文对象当Flask应用真正处理请求时，wsgi_app(environ, start_response)被调用。这个函数是按照下面的方式运行的： 123def wsgi_app(environ, start_response): with self.request_context(environ): ... 请求上下文可以看到，当Flask应用处理一个请求时，会构造一个上下文对象。所有的请求处理过程，都会在这个上下文对象中进行。这个上下文对象是_RequestContext类的实例。 12345678910111213141516171819202122232425# Flask v0.1class _RequestContext(object): """The request context contains all request relevant information. It is created at the beginning of the request and pushed to the `_request_ctx_stack` and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided. """ def __init__(self, app, environ): self.app = app self.url_adapter = app.url_map.bind_to_environ(environ) self.request = app.request_class(environ) self.session = app.open_session(self.request) self.g = _RequestGlobals() self.flashes = None def __enter__(self): _request_ctx_stack.push(self) def __exit__(self, exc_type, exc_value, tb): # do not pop the request stack if we are in debug mode and an # exception happened. This will allow the debugger to still # access the request object in the interactive shell. if tb is None or not self.app.debug: _request_ctx_stack.pop() 根据_RequestContext上下文对象的定义，可以发现，在构造这个对象的时候添加了和Flask应用相关的一些属性： app ——上下文对象的app属性是当前的Flask应用； url_adapter ——上下文对象的url_adapter属性是通过Flask应用中的Map实例构造成一个MapAdapter实例，主要功能是将请求中的URL和Map实例中的URL规则进行匹配； request ——上下文对象的request属性是通过Request类构造的实例，反映请求的信息； session ——上下文对象的session属性存储请求的会话信息； g ——上下文对象的g属性可以存储全局的一些变量。 flashes ——消息闪现的信息。 LocalStack和一些“全局变量”注意： 当进入这个上下文对象时，会触发_request_ctx_stack.push(self)。在这里需要注意Flask中使用了werkzeug库中定义的一种数据结构LocalStack。 1_request_ctx_stack = LocalStack() 关于LocalStack，可以参考：Werkzeug库——local模块。LocalStack是一种栈结构，每当处理一个请求时，请求上下文对象_RequestContext会被放入这个栈结构中。数据在栈中存储的形式表现成如下： 1&#123;880: &#123;'stack': [&lt;flask._RequestContext object&gt;]&#125;, 13232: &#123;'stack': [&lt;flask._RequestContext object&gt;]&#125;&#125; 这是一个字典形式的结构，键代表当前线程/协程的标识数值，值代表当前线程/协程存储的变量。werkzeug.local模块构造的这种结构，很容易实现线程/协程的分离。也正是这种特性，使得可以在Flask中访问以下的“全局变量”： 1234current_app = LocalProxy(lambda: _request_ctx_stack.top.app)request = LocalProxy(lambda: _request_ctx_stack.top.request)session = LocalProxy(lambda: _request_ctx_stack.top.session)g = LocalProxy(lambda: _request_ctx_stack.top.g) 其中_request_ctx_stack.top始终指向当前线程/协程中存储的“请求上下文”，这样像app、request、session、g等都可以以“全局”的形式存在。这里“全局”是指在当前线程或协程当中。 由此可以看出，当处理请求时： 首先，会生成一个请求上下文对象，这个上下文对象包含请求相关的信息。并且在进入上下文环境时，LocalStack会将这个上下文对象推入栈结构中以存储这个对象； 在这个上下文环境中可以进行请求处理过程，这个稍后再介绍。不过可以以一种“全局”的方式访问上下文对象中的变量，例如app、request、session、g等； 当请求结束，退出上下文环境时，LocalStack会清理当前线程/协程产生的数据（请求上下文对象）； Flask 0.1版本只有“请求上下文”的概念，在Flask 0.9版本中又增加了“应用上下文”的概念。关于“应用上下文”，以后再加以分析。 4. 在上下文环境中处理请求处理请求的过程定义在wsgi_app方法中，具体如下： 12345678def wsgi_app(environ, start_response): with self.request_context(environ): rv = self.preprocess_request() if rv is None: rv = self.dispatch_request() response = self.make_response(rv) response = self.process_response(response) return response(environ, start_response) 从代码可以看出，在上下文对象中处理请求的过程分为以下几个步骤： 在请求正式被处理之前的一些操作，调用preprocess_request()方法，例如打开一个数据库连接等操作； 正式处理请求。这个过程调用dispatch_request()方法，这个方法会根据URL匹配的情况调用相关的视图函数； 将从视图函数返回的值转变为一个Response对象； 在响应被发送到WSGI服务器之前，调用process_response(response)做一些后续处理过程； 调用response(environ, start_response)方法将响应发送回WSGI服务器。关于此方法的使用，可以参考：Werkzeug库——wrappers模块； 退出上下文环境时，LocalStack会清理当前线程/协程产生的数据（请求上下文对象）。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/一个Flask应用运行过程剖析/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Werkzeug库——local模块]]></title>
      <url>%2FFlask%2FWerkzeug%E5%BA%93%E2%80%94%E2%80%94local%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[一、简介在local模块中，Werkzeug实现了类似Python标准库中thread.local的功能。thread.local是线程局部变量，也就是每个线程的私有变量，具有线程隔离性，可以通过线程安全的方式获取或者改变线程中的变量。参照thread.local，Werkzeug实现了比thread.local更多的功能。Werkzeug官方文档关于local模块中对此进行了说明： The Python standard library comes with a utility called “thread locals”. A thread local is a global object in which you can put stuff in and get back later in a thread-safe way. That means whenever you set or get an object on a thread local object, the thread local object checks in which thread you are and retrieves the correct value. This, however, has a few disadvantages. For example, besides threads there are other ways to handle concurrency in Python. A very popular approach is greenlets. Also, whether every request gets its own thread is not guaranteed in WSGI. It could be that a request is reusing a thread from before, and hence data is left in the thread local object. 总结起来： 以上文档解释了对于“并发”问题，多线程并不是唯一的方式，在Python中还有“协程”(关于协程的概念和用法可以参考：廖雪峰的博客)。“协程”的一个显著特点在于是一个线程执行，一个线程可以存在多个协程。也可以理解为：协程会复用线程。对于WSGI应用来说，如果每一个线程处理一个请求，那么thread.local完全可以处理，但是如果每一个协程处理一个请求，那么一个线程中就存在多个请求，用thread.local变量处理起来会造成多个请求间数据的相互干扰。 对于上面问题，Werkzeug库解决的办法是local模块。local模块实现了四个类： Local LocalStack LocalProxy LocalManager 本文重点介绍前两个类的实现。 二、Local类Local类能够用来存储线程的私有变量。在功能上这个thread.local类似。与之不同的是，Local类支持Python的协程。在Werkzeug库的local模块中，Local类实现了一种数据结构，用来保存线程的私有变量，对于其具体形式，可以参考它的构造函数： 123456class Local(object): __slots__ = ('__storage__', '__ident_func__') def __init__(self): object.__setattr__(self, '__storage__', &#123;&#125;) object.__setattr__(self, '__ident_func__', get_ident) 从上面类定义可以看出，Local类具有两个属性：__storage__和__ident_func__。从构造函数来看，__storage__是一个字典，而__ident_func__是一个函数，用来识别当前线程或协程。 1. __ident_func__关于当前线程或协程的识别，local模块引入get_ident函数。如果支持协程，则从greenlet库中导入相关函数，否则从thread库中导入相关函数。调用get_ident将返回一个整数，这个整数可以确定当前线程或者协程。 1234567try: from greenlet import getcurrent as get_identexcept ImportError: try: from thread import get_ident except ImportError: from _thread import get_ident 2. __storage____storage__是一个字典，用来存储不同的线程/协程，以及这些线程/协程中的变量。以下是一个简单的多线程的例子，用来说明__storage__的具体结构。 123456789101112131415import threadingfrom werkzeug.local import Locall = Local()l.__storage__def add_arg(arg, i): l.__setattr__(arg, i)for i in range(3): arg = 'arg' + str(i) t = threading.Thread(target=add_arg, args=(arg, i)) t.start()l.__storage__ 上面的例子，具体分析为： 首先，代码创建了一个Local的实例l，并且访问它的__storage__属性。由于目前还没有数据，所以l.__storage__的结果为{}; 代码创建了3个线程，每个线程均运行add_arg(arg, i)函数。这个函数会为每个线程创建一个变量，并对其赋值； 最后，再次访问l.__storage__。这次，l实例中将包含3个线程的信息。其结果为： 1&#123;20212: &#123;'arg0': 0&#125;, 20404: &#123;'arg1': 1&#125;, 21512: &#123;'arg2': 2&#125;&#125; 从以上结果可以看出，__storage__这个字典的键表示不同的线程（通过get_ident函数获得线程标识数值），而值表示对应线程中的变量。这种结构将不同的线程分离开来。当某个线程要访问该线程的变量时，便可以通过get_ident函数获得线程标识数值，进而可以在字典中获得该键对应的值信息了。 三、LocalStack类LocalStack类和Local类类似，但是它实现了栈数据结构。 在LocalStack类初始化的时候，便会创建一个Local实例，这个实例用于存储线程/协程的变量。与此同时，LocalStack类还实现了push、pop、top等方法或属性。调用这些属性或者方法时，该类会根据当前线程或协程的标识数值，在Local实例中对相应的数值进行操作。以下还是以一个多线程的例子进行说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from werkzeug.local import LocalStack, LocalProxyimport logging, random, threading, time# 定义logging配置logging.basicConfig(level=logging.DEBUG, format='(%(threadName)-10s) %(message)s', )# 生成一个LocalStack实例_stack_stack = LocalStack()# 定义一个RequestConetxt类，它包含一个上下文环境。# 当调用这个类的实例时，它会将这个上下文对象放入# _stack栈中去。当退出该上下文环境时，栈会pop其中# 的上下文对象。class RequestConetxt(object): def __init__(self, a, b, c): self.a = a self.b = b self.c = c def __enter__(self): _stack.push(self) def __exit__(self, exc_type, exc_val, exc_tb): if exc_tb is None: _stack.pop() def __repr__(self): return '%s, %s, %s' % (self.a, self.b, self.c)# 定义一个可供不同线程调用的方法。当不同线程调用该# 方法时，首先会生成一个RequestConetxt实例，并在这# 个上下文环境中先将该线程休眠一定时间，之后打印出# 目前_stack中的信息，以及当前线程中的变量信息。# 以上过程会循环两次。def worker(i): with request_context(i): for j in range(2): pause = random.random() logging.debug('Sleeping %0.02f', pause) time.sleep(pause) logging.debug('stack: %s' % _stack._local.__storage__.items()) logging.debug('ident_func(): %d' % _stack.__ident_func__()) logging.debug('a=%s; b=%s; c=%s' % (LocalProxy(lambda: _stack.top.a), LocalProxy(lambda: _stack.top.b), LocalProxy(lambda: _stack.top.c))) logging.debug('Done')# 调用该函数生成一个RequestConetxt对象def request_context(i): i = str(i+1) return RequestConetxt('a'+i, 'b'+i, 'c'+i)# 在程序最开始显示_stack的最初状态logging.debug('Stack Initial State: %s' % _stack._local.__storage__.items())# 产生两个线程，分别调用worker函数for i in range(2): t = threading.Thread(target=worker, args=(i,)) t.start()main_thread = threading.currentThread()for t in threading.enumerate(): if t is not main_thread: t.join()# 在程序最后显示_stack的最终状态logging.debug('Stack Finally State: %s' % _stack._local.__storage__.items()) 以上例子的具体分析过程如下： 首先，先创建一个LocalStack实例_stack，这个实例将存储线程/协程的变量信息； 在程序开始运行时，先检查_stack中包含的信息； 之后创建两个线程，分别执行worker函数； worker函数首先会产生一个上下文对象，这个上下文对象会放入_stack中。在这个上下文环境中，程序执行一些操作，打印一些数据。当退出上下文环境时，_stack会pop该上下文对象。 在程序结束时，再次检查_stack中包含的信息。 运行上面的测试例子，产生结果如下： 1234567891011121314151617181920(MainThread) Stack Initial State: [](Thread-1 ) Sleeping 0.31(Thread-2 ) Sleeping 0.02(Thread-2 ) stack: [(880, &#123;'stack': [a1, b1, c1]&#125;), (13232, &#123;'stack': [a2, b2, c2]&#125;)](Thread-2 ) ident_func(): 13232(Thread-2 ) a=a2; b=b2; c=c2(Thread-2 ) Sleeping 0.49(Thread-1 ) stack: [(880, &#123;'stack': [a1, b1, c1]&#125;), (13232, &#123;'stack': [a2, b2, c2]&#125;)](Thread-1 ) ident_func(): 880(Thread-1 ) a=a1; b=b1; c=c1(Thread-1 ) Sleeping 0.27(Thread-2 ) stack: [(880, &#123;'stack': [a1, b1, c1]&#125;), (13232, &#123;'stack': [a2, b2, c2]&#125;)](Thread-2 ) ident_func(): 13232(Thread-2 ) a=a2; b=b2; c=c2(Thread-2 ) Done(Thread-1 ) stack: [(880, &#123;'stack': [a1, b1, c1]&#125;)](Thread-1 ) ident_func(): 880(Thread-1 ) a=a1; b=b1; c=c1(Thread-1 ) Done(MainThread) Stack Finally State: [] 注意到： 当两个线程在运行时，_stack中会存储这两个线程的信息，每个线程的信息都保存在类似{&#39;stack&#39;: [a1, b1, c1]}的结构中（注：stack键对应的是放入该栈中的对象，此处为了方便打印了该对象的一些属性）。 当线程在休眠和运行中切换时，通过线程的标识数值进行区分不同线程，线程1运行时它通过标识数值只会对属于该线程的数值进行操作，而不会和线程2的数值混淆，这样便起到线程隔离的效果（而不是通过锁的方式）。 由于是在一个上下文环境中运行，当线程执行完毕时，_stack会将该线程存储的信息删除掉。在上面的运行结果中可以看出，当线程2运行结束后，_stack中只包含线程1的相关信息。当所有线程都运行结束，_stack的最终状态将为空。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Werkzeug库——local模块/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Werkzeug库——routing模块]]></title>
      <url>%2FFlask%2FWerkzeug%E5%BA%93%E2%80%94%E2%80%94routing%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[Werkzeug库的routing模块的主要功能在于URL解析。对于WSGI应用来讲，不同的URL对应不同的视图函数，routing模块则会对请求信息的URL进行解析并匹配，触发URL对应的视图函数，以此生成一个响应信息。routing模块的解析和匹配功能主要体现在三个类上：Rule、Map和MapAdapter。 Rule类Rule类继承自RuleFactory类。一个Rule的实例代表一个URL模式，一个WSGI应用可以处理很多不同的URL模式，这也就是说可以产生很多不同的Rule实例。这些Rule实例最终会作为参数传递给Map类，形成一个包含所有URL模式的对象，通过这个对象可以解析并匹配请求对应的视图函数。 关于Rule类有一些常用的方法： empty() ——在实际情况中，Rule实例会和一个Map实例进行绑定。通过empty()方法可以将Rule实例和Map实例解除绑定。 get_empty_kwargs() ——在empty()方法中调用，可以获得之前Rule实例的参数，以便重新构造一个Rule实例。 get_rules(map) ——这个方法是对RuleFactory类中get_rules方法的重写，返回Rule实例本身。 refresh() ——当修改Rule实例（URL规则）后可以调用该方法，以便更新Rule实例和Map实例的绑定关系。 bind(map, rebind=False) ——将Rule实例和一个Map实例进行绑定，这个方法会调用complie()方法，会给Rule实例生成一个正则表达式。 complie() ——根据Rule实例的URL模式，生成一个正则表达式，以便后续对请求的path进行匹配。 match(path) ——将Rule实例和给定的path进行匹配。在调用complie()方法生成的正则表达式将会对path进行匹配。如果匹配，将返回这个path中的参数，以便后续过程使用。如果不匹配，将会由其他的Rule实例和这个path进行匹配。 注意： 在对给定的URL进行匹配的过程中，会使用一些Converters。关于Converters的信息后续加以介绍。 Map类通过Map类构造的实例可以存储所有的URL规则，这些规则是Rule类的实例。Map实例可以 通过后续的调用和给定的URL进行匹配。 关于Map类有一些常用的方法： add(rulefactory) ——这个方法在构造Map实例的时候就会调用，它会将所有传入Map类中的Rule实例和该Map实例建立绑定关系。该方法还会调用Rule实例的bind方法。 bind方法 ——这个方法会生成一个MapAdapter实例，传入MapAdapter的包括一些请求信息，这样可以调用MapAdapter实例的方法匹配给定URL。 bind_to_environ方法 ——通过解析请求中的environ信息，然后调用上面的bind方法，最终会生成一个MapAdapter实例。 MapAdapter类MapAdapter类执行URL匹配的具体工作。关于MapAdapter类有一些常用的方法： dispatch方法 ——该方法首先会调用MapAdapter实例的match()方法，如果有匹配的Rule，则会执行该Rule对应的视图函数。 match方法 ——该方法将会进行具体的URL匹配工作。它会将请求中的url和MapAdapter实例中的所有Rule进行匹配，如果有匹配成功的，则返回该Rule对应的endpoint和一些参数rv。endpoint一般会对应一个视图函数，返回的rv可以作为参数传入视图函数中。 一个简单的例子为了说明routing模块的工作原理，这里使用Werkzeug文档中的一个例子，稍加改动后如下所示： 1234567891011121314151617181920212223242526from werkzeug.routing import Map, Rule, NotFound, RequestRedirect, HTTPExceptionurl_map = Map([ Rule('/', endpoint='blog/index'), Rule('/&lt;int:year&gt;/', endpoint='blog/archive'), Rule('/&lt;int:year&gt;/&lt;int:month&gt;/', endpoint='blog/archive'), Rule('/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/', endpoint='blog/archive'), Rule('/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;slug&gt;', endpoint='blog/show_post'), Rule('/about', endpoint='blog/about_me'), Rule('/feeds/', endpoint='blog/feeds'), Rule('/feeds/&lt;feed_name&gt;.rss', endpoint='blog/show_feed')])def application(environ, start_response): urls = url_map.bind_to_environ(environ) try: endpoint, args = urls.match() except HTTPException, e: return e(environ, start_response) start_response('200 OK', [('Content-Type', 'text/plain')]) return ['Rule points to %r with arguments %r' % (endpoint, args)]if __name__ == '__main__': from werkzeug.serving import run_simple run_simple('localhost', 4000, application) 这里我们使用werkzeug自带的服务器模块构造了一个Web服务器，并且设计了一个简单的WSGI应用——application。这个Web服务器可以根据URL的不同返回不同的结果。关于服务器的构造这里不再赘述，以下部分简单对URL Routing过程进行分析： 1. 设计URL模式设计URL模式的过程就是构造Rule实例的过程。上面的例子中我们构造了8个Rule实例，分别对应8个不同的URL模式。每个Rule实例还对应一个endpoint，这个endpoint可以和视图函数进行对应，以便访问某个URL时，可以触发与之对应的视图函数。下面的例子展示了endpoint和视图函数的对应关系。 12345678from werkzeug.wrappers import Responsefrom werkzeug.routing import Map, Ruledef on_index(request): return Response('Hello from the index')url_map = Map([Rule('/', endpoint='index')])views = &#123;'index': on_index&#125; 2. 构造Map实例构造Map实例时，会调用它的add(rulefactory)方法。这个方法会在Map实例和各个Rule实例之间建立绑定关系，并通过调用Rule实例的bind()方法为每个Rule实例生成一个正则表达式。 例如，对于&#39;/about&#39;这个URL，它对应的正则表达式为： &#39;^\\|\\/about$&#39; 对于&#39;/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&#39;这个URL，它对应的正则表达式为： &#39;^\\|\\/(?P&lt;year&gt;\\d+)\\/(?P&lt;month&gt;\\d+)\\/(?P&lt;day&gt;\\d+)(?&lt;!/)(?P&lt;__suffix__&gt;/?)$&#39; 3. 构造MapAdapter实例在设计WSGI应用时，上述例子通过url_map.bind_to_environ(environ)构建了一个MapAdapter实例。这个实例将请求的相关信息和已经创建好的Map实例放在一起，以便进行URL匹配。 进行URL匹配的过程是通过调用MapAdapter实例的match()方法进行的。实质上，这个方法会将请求中的path传入到所有Rule实例的match(path)方法中，经过正则表达式的匹配来分析path是否和某个Rule实例匹配。如果匹配则返回对应的endpoint和其他的参数，这可以作为参数传入视图函数。 4. 访问URL可得相关结果之后，访问URL可以得到相对应的结果。 例如，访问http://localhost:4000/2017/，可以得到： Rule points to &#39;blog/archive&#39; with arguments {&#39;year&#39;: 2017} 访问http://localhost:4000/2017/3/20/，可以得到： Rule points to &#39;blog/archive&#39; with arguments {&#39;month&#39;: 3, &#39;day&#39;: 20, &#39;year&#39;: 2017} 访问http://localhost:4000/about，可以得到： Rule points to &#39;blog/about_me&#39; with arguments {} 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Werkzeug库——routing模块/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Werkzeug库——wrappers模块]]></title>
      <url>%2FFlask%2FWerkzeug%E5%BA%93%E2%80%94%E2%80%94wrappers%E6%A8%A1%E5%9D%97%2F</url>
      <content type="text"><![CDATA[Werkzeug库中的wrappers模块主要对request和response进行封装。request包含了客户端发往服务器的所有请求信息，response包含了web应用返回给客户端的所有信息。wrappers模块对请求和响应的封装简化了客户端、服务器和web应用通信的流程。本文主要介绍wrappers模块中重要的类。 BaseRequestBaseRequest是一个非常基础的请求类，它可以和其他的“混合”类结合在一起构建复杂的请求类。只要传递一个环境变量environ（由WSGI服务器根据请求产生），便可以构造一个BaseRequest实例。其构造函数如下： 12345def __init__(self, environ, populate_request=True, shallow=False): self.environ = environ if populate_request and not shallow: self.environ['werkzeug.request'] = self self.shallow = shallow 初始化后，形成的实例request便具有了一些属性可以访问，这些属性只能以“只读”的方式访问。例如： url_charset want_form_data_parsed stream args data form values files cookies headers path full_path script_root url base_url url_root host_url host access_route remote_addr BaseRequest中还有两个类方法比较常用： from_values(cls, *args, kwargs)** 123456789101112131415161718192021222324252627@classmethoddef from_values(cls, *args, **kwargs): """Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (:class:`Client`) that allows to create multipart requests, support for cookies etc. This accepts the same options as the :class:`~werkzeug.test.EnvironBuilder`. .. versionchanged:: 0.5 This method now accepts the same arguments as :class:`~werkzeug.test.EnvironBuilder`. Because of this the `environ` parameter is now called `environ_overrides`. :return: request object """ from werkzeug.test import EnvironBuilder charset = kwargs.pop('charset', cls.charset) kwargs['charset'] = charset builder = EnvironBuilder(*args, **kwargs) try: return builder.get_request(cls) finally: builder.close() 这个类方法可以根据提供的参数构建一个请求。 application(cls, f) 123456789101112131415161718192021222324@classmethoddef application(cls, f): """Decorate a function as responder that accepts the request as first argument. This works like the :func:`responder` decorator but the function is passed the request object as first argument and the request object will be closed automatically:: @Request.application def my_wsgi_app(request): return Response('Hello World!') :param f: the WSGI callable to decorate :return: a new WSGI callable """ #: return a callable that wraps the -2nd argument with the request #: and calls the function with all the arguments up to that one and #: the request. The return value is then called with the latest #: two arguments. This makes it possible to use this decorator for #: both methods and standalone WSGI functions. def application(*args): request = cls(args[-2]) with request: return f(*args[:-2] + (request,))(*args[-2:]) return update_wrapper(application, f) 这个类方法是一个装饰器，可以用来装饰WSGI可调用对象或函数。 以上属性和方法的具体用法可以参考Request——werkzeug文档。 BaseResponseBaseResponse类是一个响应类，用它可以封装一个response对象。response对象最大的特点是它是一个WSGI应用。 在之前介绍WSGI规范的文章中曾介绍过Web服务器网关，它简化了服务器和web应用之间的通信过程，它要求服务器和web应用要遵循WSGI规范进行开发。对于web应用而言，应用应该实现一个函数或者一个可调用对象，这样WSGI服务器可以通过调用myWebApp(environ, start_response)从web应用获得响应内容。 response响应对象就是这样一个WSGI应用对象。在其实现过程中有一个__call__方法，可以实现对一个response对象的调用。代码如下： 1234567891011def __call__(self, environ, start_response): """Process this response as WSGI application. :param environ: the WSGI environment. :param start_response: the response callable provided by the WSGI server. :return: an application iterator """ app_iter, status, headers = self.get_wsgi_response(environ) start_response(status, headers) return app_iter 这样，我们就可以很清楚地理解WSGI应用的实现过程。下面是一个非常简单的WSGI应用。 123456from werkzeug.wrappers import Request, Responsedef application(environ, start_response): request = Request(environ) response = Response("Hello %s!" % request.args.get('name', 'World!')) return response(environ, start_response) 上面的小例子的实现步骤分析： 根据传入web应用的environ构造请求对象request； web应用构造响应对象response； 调用响应对象response。调用过程中产生三个值：app_iter、status、headers，其中status和headers作为参数传递给函数start_response用于生成响应报文首行的相关信息，而app_iter作为响应的内容（它是一个可迭代对象）返回给WSGI网关； WSGI网关将返回的信息组成响应首行、响应首部、响应主体等，形成响应报文发回给客户端。 BaseResponse类中还有一些属性和方法，以下属性和方法的具体用法可以参考Response——werkzeug文档。 属性 status_code status data is_stream is_sequence ······ 方法 call_on_close(func) close() freeze() force_type() 类方法 from_app() 类方法 set_data() get_data() _ensure_sequence() make_sequence() iter_encoded() calculate_content_length() set_cookie() delete_cookie() get_wsgi_headers(environ) get_app_iter(environ) get_wsgi_response(environ) __call__(environ, start_response) ······ Mixin类BaseRequest类和BaseResponse类是请求和响应最基础的类。wrappers模块中还提供了一些Mixin类，用于扩展请求类和响应类。 有关请求类的Mixin类有关请求类的Mixin类主要有： AcceptMixin类 ——请求报文中关于客户端希望接收的数据类型的类。 ETagRequestMixin类 ——请求报文中关于Etag和Cache的类。 UserAgentMixin类 ——请求报文中关于user_agent的类。 AuthorizationMixin类 ——请求报文中关于认证的类。 CommonRequestDescriptorsMixin类 ——通过这个类可以获取请求首部中的相关信息。 有关响应类的Mixin类有关响应类的Mixin类主要有： ETagResponseMixin类 ——为响应增加Etag和Cache控制的类。 ResponseStreamMixin类 ——为响应可迭代对象提供一个“只写”的接口的类。 CommonResponseDescriptorsMixin类 ——通过这个类可以获取响应首部中的相关信息。 WWWAuthenticateMixin类 ——为响应提供认证的类。 Request和Response终于讲到Request类和Response类了。 Request类继承自BaseRequest类，并且结合一些请求相关的Mixin类，具体如下： 123class Request(BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthorizationMixin, CommonRequestDescriptorsMixin) Response类继承自BaseResponse类，并且结合一些响应相关的Mixin类，具体如下： 123class Response(BaseResponse, ETagResponseMixin, ResponseStreamMixin, CommonResponseDescriptorsMixin, WWWAuthenticateMixin) 至此，可以从wrappers模块中引入Request类和Response用于构建请求对象和响应对象。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Werkzeug库——wrappers模块/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Werkzeug库简介]]></title>
      <url>%2FFlask%2FWerkzeug%E5%BA%93%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[简介Werkzeug是一个Python写成的WSGI工具集。它遵循WSGI规范，对服务器和Web应用之间的“中间层”进行了开发，衍生出一系列非常有用的Web服务底层模块。关于Werkzeug功能的最简单的一个例子如下： 12345678910from werkzeug.wrappers import Request, Responsedef application(environ, start_response): request = Request(environ) response = Response("Hello %s!" % request.args.get('name', 'World!')) return response(environ, start_response)if __name__ == '__main__': from werkzeug.serving import run_simple run_simple('localhost', 4000, application) 运行上面的例子，当在浏览器输入http://localhost:4000/就会向本地的服务器发出一个请求。在请求的过程中，werkzeug主要做了下面几件事情： 根据服务器和WSGI服务器产生的environ环境信息，封装一个Request实例，这个实例包含请求的所有信息； Web应用根据封装的Request实例信息，产生一个Response实例（上述例子只是输出一段字符串）。这个Response实例是一个可调用的WSGI应用； 上一步骤产生的可调用应用对象response调用response(environ, start_response)生成响应信息并发回客户端。调用函数是由WSGI规范规定的。 以上过程很好地将服务器和web应用分离开来：服务器不用考虑请求信息怎么被解析给web应用，以及后续怎么和web应用通信；web应用也不用考虑怎么将响应信息返回给服务器。服务器要做的只是提供web应用所需的请求信息，web应用提供的也只是响应信息，中间的处理过程werkzeug可以帮助完成。 模块werkzeug库主要的模块有： Werkzeug库——wrappers模块 Werkzeug库——routing模块 Werkzeug库——local模块 后续继续更新······ 详情可以查看介绍各模块的具体文章。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Flask/Werkzeug库简介/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[wsgiref包——符合WSGI标准的Web服务实现（一）]]></title>
      <url>%2FPython%2Fwsgiref%E5%8C%85%E2%80%94%E2%80%94%E7%AC%A6%E5%90%88WSGI%E6%A0%87%E5%87%86%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[引子在前几篇文章：SocketServer——网络通信服务器、BaseHTTPServer——实现Web服务器、SimpleHTTPServer——一个简单的HTTP服务器，我们介绍了Python标准库对于网络通信的支持，并且还介绍了标准库中的一些模块，例如TCPServer、UDPServer、BaseHTTPServer等。这些模块能够实现基础的网路通信服务，例如TCP/UDP层的通信、HTTP应用层的通信。 上述模块对于网络通信的实现，基本的流程是： 创建一个服务器。例如TCP服务器、UDP服务器、HTTP服务器。服务器可以监听和接收请求； 创建请求处理程序。请求处理程序可以解析到达的请求，并发回一个响应。 以上流程基本上反映了Python标准库中关于网络通信的基本过程。服务器类和请求处理类的解耦，意味着很多应用可以使用某个现有的服务器类，而不需要其他任何的修改，只需要提供一个可以处理这些应用的请求处理类即可。但随着近些年网络编程越来越复杂，对于服务器网络通信提出了较大的挑战。以Web编程为例，挑战主要在于： 服务器不再仅仅提供简单的、静态的HTML页面，更多的是要与丰富的Web应用进行相互通信。如果将请求处理程序的构建放在服务器端实现，那对于每个Web应用构建一个请求处理程序显然不现实； 如果将请求处理程序的构建放在开发Web应用的过程中，那无疑增加了Web应用程序开发的难度和复杂度，也是不太理想的。 为了解决这些问题，常用的做法是提供一个中间层，通常称为网关接口。网关接口在服务器和应用中间承担一个“翻译官”的角色。只要应用程序符合网关接口的标准，那么服务器就只要做好服务器的角色，应用程序只要做好应用程序的作用，服务器和应用程序之间的通信全靠网关接口来协调。常用的网关接口有CGI、WSGI，本文就以WSGI网关接口来对此进行说明。 WSGI网关接口WSGI (Python Web Server Gateway Interface, Python Web服务器网关接口)是一个Web服务器和Web应用程序之间的标准化接口，用于增进应用程序在不同的Web服务器和框架之间的可移植性。关于该标准的官方说明可以参考PEP333。 WSGI的主要作用是在Web服务器和Web应用程序承担“翻译官”的角色。对于这一角色可以这样理解： Web服务器的责任在于监听和接收请求。在处理请求的时候调用WSGI提供的标准化接口，将请求的信息转给WSGI； WSGI的责任在于“中转”请求和响应信息。WSGI接收到Web服务器提供的请求信息后可以做一些处理，之后通过标准化接口调用Web应用，并将请求信息传递给Web应用。同时，WSGI还将会处理Web应用返回的响应信息，并通过服务器返回给客户端； Web应用的责任在于接收请求信息，并且生成响应。 根据以上分析，要实现符合WSGI标准的Web服务，服务器和应用程序的设计就要符合WSGI规范。 WSGI规范WSGI规范如下： 服务器的请求处理程序中要调用符合WSGI规范的网关接口； 网关接口调用应用程序，并且要定义start_response(status, headers)函数，用于返回响应； 应用程序中实现一个函数或者一个可调用对象webapp(environ, start_response)。其中environ是环境设置的字典，由服务器和WSGI网关接口设置，start_response是由网关接口定义的函数。 在Python标准库中，wsgiref包就是符合WSGI标准的Web服务实现。后面简单对wsgiref包进行介绍，以此来对符合WSGI标准的Web服务的实现过程进行梳理。 wsgiref包wsgiref包为实现WSGI标准提供了一个参考，它可以作为独立的服务器测试和调试应用程序。在实际的生产环境中尽量不要使用。wsgiref包含有以下模块： simple_server模块 ——simple_server模块实现了可以运行单个WSGI应用的简单的HTTP服务器。 headers模块 ——管理响应首部的模块。 handlers模块 ——符合WSGI标准的Web服务网关接口实现。该模块包含了一些处理程序对象，用来设置WSGI执行环境，以便应用程序能够在其他的Web服务器中运行。 validate模块 ——“验证包装”模块，确保应用程序和服务器都能够按照WSGI标准进行操作。 util模块 ——一些有用的工具集。 以上模块暂时不做详细的介绍。本文剩余内容将simple_server模块单独拿出来，以其中的测试例子简单说明符合WSGI标准的Web服务器的实现过程。 simple_server——一个简单的符合WSGI规范的服务器wsgiref包的simple_server模块实现了一个符合WSGI规范的服务器。测试代码如下： 12345678if __name__ == '__main__': httpd = make_server('', 8000, demo_app) sa = httpd.socket.getsockname() print "Serving HTTP on", sa[0], "port", sa[1], "..." import webbrowser webbrowser.open('http://localhost:8000/xyz?abc') httpd.handle_request() # serve one request, then exit httpd.server_close() 1. 创建HTTP服务器上述测试代码中httpd = make_server(&#39;&#39;, 8000, demo_app)创建了一个HTTP服务器。 其中make_server函数用来创建服务器： 1234567def make_server( host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler): """Create a new WSGI server listening on `host` and `port` for `app`""" server = server_class((host, port), handler_class) server.set_app(app) return server make_server函数使用WSGIServer类构建符合WSGI规范的HTTP服务器，使用WSGIRequestHandler类作为处理请求的类，使用demo_app作为一个Web应用。该函数返回一个服务器实例，并开始监听请求。可以通过httpd.socket.getsockname()获取服务器地址和端口号。 2. 使用webbrowser模块创建请求紧接着，测试例子导入webbrowser模块，使用函数创建了一个请求。 1webbrowser.open('http://localhost:8000/xyz?abc') 3. 服务器处理请求服务器通过handle_request()方法处理请求。关于处理请求的过程简单介绍如下： handle_request()方法通过调用get_request、verify_request、process_request、finish_request等方法创建一个请求处理实例（该过程可以参考TCPServer、HTTPServer的实现过程）； 请求处理实例调用handle()方法处理请求。handle()在WSGIRequestHandler类中进行了重写。代码如下： 12345678910111213141516171819def handle(self): """Handle a single HTTP request""" self.raw_requestline = self.rfile.readline(65537) if len(self.raw_requestline) &gt; 65536: self.requestline = '' self.request_version = '' self.command = '' self.send_error(414) return if not self.parse_request(): # An error code has been sent, just exit return handler = ServerHandler( self.rfile, self.wfile, self.get_stderr(), self.get_environ() ) handler.request_handler = self # backpointer for logging handler.run(self.server.get_app()) 上面handle()函数先解析了请求，之后创建了一个WSGI网关类实例handler，这个实例可以作为服务器和应用程序之间的接口存在。 4. WSGI网关的请求处理过程WSGI网关的定义在handlers模块。上一步骤中通过调用WSGI网关类实例handler的run方法，WSGI网关开始处理请求。 run方法的代码如下： 123456789101112131415161718def run(self, application): """Invoke the application""" # Note to self: don't move the close()! Asynchronous servers shouldn't # call close() from finish_response(), so if you close() anywhere but # the double-error branch here, you'll break asynchronous servers by # prematurely closing. Async servers must return from 'run()' without # closing if there might still be output to iterate over. try: self.setup_environ() self.result = application(self.environ, self.start_response) self.finish_response() except: try: self.handle_error() except: # If we get an error handling an error, just give up already! self.close() raise # ...and let the actual server figure it out. run方法的主要功能有： 通过setup_environ()方法创建WSGI相关的环境； 调用WSGI应用的函数或者WSGI应用的可调用对象。本测试例子中的WSGI应用是一个简单的函数，其作用是将请求的environ信息打印出来。 调用finish_response()方法将WSGI应用返回的数据作为响应发回。 5. 关闭服务器请求结束后，服务器会调用一系列函数关闭请求连接。之后测试代码调用server_close()方法关闭服务器。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Python/wsgiref包——符合WSGI标准的Web服务实现（一）/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SimpleHTTPServer——一个简单的HTTP服务器]]></title>
      <url>%2FPython%2FSimpleHTTPServer%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[Python标准库中的BaseHTTPServer模块实现了一个基础的HTTP服务器基类和HTTP请求处理类。这在文章BaseHTTPServer——实现Web服务器中进行了相关的介绍。然而，BaseHTTPServer模块中并没有定义相关的请求方法，诸如GET、HEAD、POST等。在BaseHTTPServer模块的基础上，Python标准库中的SimpleHTTPServer模块实现了简单的GET、HEAD请求。 在该模块中，它沿用了BaseHTTPServer模块中实现的HTTPServer服务器，这里就不再赘述。而请求处理类则是继承了BaseHTTPServer模块中的BaseHTTPRequestHandler类。SimpleHTTPServer模块实现了具有GET、HEAD请求方法的HTTP通信服务。根据文章BaseHTTPServer——实现Web服务器中的介绍，只需要在请求处理类中定义do_GET()和do_HEAD()方法即可。 do_GET()do_GET()方法的源码如下： 12345678def do_GET(self): """Serve a GET request.""" f = self.send_head() if f: try: self.copyfile(f, self.wfile) finally: f.close() 在这个方法中，它调用了send_head()方法来返回一个响应。send_head()方法会调用send_response()、send_header()、send_error()方法等设置响应报文等。 do_HEAD()do_HEAD()方法的源码如下： 12345def do_HEAD(self): """Serve a HEAD request.""" f = self.send_head() if f: f.close() do_HEAD()方法和do_GET()方法的实现类似。 测试例子SimpleHTTPServer模块还提供了一个测试函数。只需要在命令行中运行如下代码： 1python SimpleHTTPServer.py # SimpleHTTPServer.py指代Python标准库中的SimpleHTTPServer模块，注意文件位置。 如果在本地环境中运行以上代码，将会调用请求处理类的translate_path和list_directory方法展示一个文件目录。 然后在浏览器中访问127.0.0.1:8000即可查看SimpleHTTPServer.py文件所在目录下的所有文件。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Python/SimpleHTTPServer——一个简单的HTTP服务器/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BaseHTTPServer——实现Web服务器]]></title>
      <url>%2FPython%2FBaseHTTPServer%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0Web%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[在SocketServer——网络通信服务器中我们介绍了Python标准库中的SocketServer模块，了解了要实现网络通信服务，就要构建一个服务器类和请求处理类。同时，该模块还为我们创建了不同的服务器类和请求处理类。 服务器类 BaseServer TCPServer(BaseServer) UDPServer(TCPServer) UnixStreamServer UnixDatagramServer 请求处理类 BaseRequestHandler StreamRequestHandler(BaseRequestHandler) DatagramRequestHandler(BaseRequestHandler) 通过服务器类和请求处理类的搭配，我们可以创建不同类型的服务器，实现不同的协议类型。本文介绍的BaseHTTPServer模块便是继承TCPServer和StreamRequestHandler，实现了Web服务器的通信。 HTTP服务器HTTP服务器继承自SocketServer模块中的TCPServer类。它的定义非常简单，只是重写了其中的一个方法。 12345678910class HTTPServer(SocketServer.TCPServer): allow_reuse_address = 1 # Seems to make sense in testing environment def server_bind(self): """Override server_bind to store the server name.""" SocketServer.TCPServer.server_bind(self) host, port = self.socket.getsockname()[:2] self.server_name = socket.getfqdn(host) self.server_port = port 重写的server_bind()方法主要是为了获取服务器名和端口。其余方法以及服务器的实现过程详见SocketServer——网络通信服务器。 此外，还可以从SocketServer模块中引入’mix-in’类，基于HTTPServer创建支持进程或线程的服务器。 HTTP请求处理基类为了处理HTTP请求，BaseHTTPServer模块构造了HTTP请求处理基类BaseHTTPRequestHandler，它继承自SocketServer模块中的StreamRequestHandler类。 HTTP请求处理基类中有一些重要的方法： handle() ——这个方法是请求处理类真正处理请求具体工作的方法，例如解析到来的请求，处理数据，并发回响应等。在BaseHTTPRequestHandler中它是一个入口文件，将调用其他的方法完成请求处理。 handle_one_request() ——由handle()调用，用于处理请求。其主要工作包括： 调用parse_request()方法，解析请求，获取请求报文中的信息，包括请求的方法、请求URL、请求的HTTP版本号、请求首部等。如果解析失败，则调用send_error()方法发回一个错误响应。 调用do_SPAM() 方法。这个方法中的SPAM指代GET、POST、HEAD等请求方法，需要在请求处理类中构建具体的请求处理方法，例如do_GET处理GET请求，do_POST处理POST请求。do_SPAM() 方法可以调用send_response()、send_header()、end_headers()等方法创建响应首行和响应首部等内容。 parse_request() ——解析请求。 send_error() ——发回错误响应。 send_response() ——创建响应首行和响应首部等内容。 send_header() ——设置响应首部内容。 end_headers() ——调用此方法可以在首部后增加一个空行，表示首部内容结束（不适用于HTTP/0.9） 还包括其他的一些辅助函数。 需要注意的是：BaseHTTPRequestHandler是HTTP请求处理的基类，并不包含诸如do_GET、do_POST等方法，其他继承该类的请求处理类需要自己实现这些方法，已完成对具体请求的处理。对此，可以参考SimpleHTTPServer模块，也可查看文章SimpleHTTPServer——一个简单的HTTP服务器。 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Python/BaseHTTPServer——实现Web服务器/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SocketServer——网络通信服务器]]></title>
      <url>%2FPython%2FSocketServer%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
      <content type="text"><![CDATA[SocketServer是Python标准库中的一个模块，其作用是创建网络服务器。SocketServer模块定义了一些类来处理诸如TCP、UDP、UNIX流和UNIX数据报之上的同步网络请求。 SocketServer模块处理网络请求的功能，可以通过两个主要的类来实现：一个是服务器类，一个是请求处理类。 服务器类 处理通信问题，如监听一个套接字并接收连接等； 请求处理类 处理“协议”问题，如解释到来的数据、处理数据并把数据发回给客户端等。 这种实现将服务器的实现过程和请求处理的实现过程解耦，这意味着我们可以将不同的服务器实现和请求处理实现结合起来来处理一些定制的协议，例如一个TCP服务器类和一个流请求处理类结合，处理基于TCP的网络请求。同时，也可以基于SocketServer模块中的服务器类和请求处理类，实现网络层之上应用层的服务器和请求处理实现，例如基于TCP服务器类实现HTTP服务器，基于流处理请求类实现HTTP请求处理类等。 服务器类SocketServer模块中定义了五种服务器类。 BaseServer(服务器的基类，定义了API) TCPServer(使用TCP/IP套接字) UDPServer(使用数据报套接字) UnixStreamServer(使用UNIX域套接字，只适用UNIX平台) UnixDatagramServer(使用UNIX域套接字，只适用UNIX平台) 1. 构造服务器对象要构建一个服务器对象，需要向它传递一个地址server_address（服务器将在这个地址上监听请求），以及一个请求处理类RequestHandlerClass（不是请求处理实例）。服务器类基类的构造函数如下： 12345678class BaseServer: def __init__(self, server_address, RequestHandlerClass): """Constructor. May be extended, do not override.""" self.server_address = server_address self.RequestHandlerClass = RequestHandlerClass self.__is_shut_down = threading.Event() self.__shutdown_request = False 之后，可以构造TCPServer、UDPServer、UnixStreamServer、UnixDatagramServer。其中，TCPServer继承自BaseServer，UDPServer和UnixStreamServer继承自TCPServer，UnixDatagramServer继承自UDPServer。各个服务器类型可以根据自己的特点对基类进行扩展，例如创建监听套接字、绑定监听地址和端口、进行监听等。一旦实例化服务器对象，便可以使用服务器的方法来监听和处理请求。 2. 实现服务器由于SocketServer模块中定义的五种服务器类中，除了基类BaseServer和TCPServer外，其余的三个类都是直接或间接地继承自TCPServer。因此，以下以TCPServer的实现过程为例进行说明。 构造TCPServer。 构造TCPServer时，构造函数创建了一个套接字（这个套接字可以通过更改地址簇和类型用于其他服务器）用于监听请求。并且调用server_bind()绑定监听的地址和端口，调用server_activate()开始监听。 启动服务器。 服务器实例化后，可以使用serve_forever()或者handle_request()来监听和处理请求，实现服务器功能。这两个方法的具体实现依赖于_handle_request_noblock()方法。这个方法是BaseServer类中定义的。具体实现如下： 12345678910111213141516171819def _handle_request_noblock(self): """Handle one request, without blocking. I assume that select.select has returned that the socket is readable before this function was called, so there should be no risk of blocking in get_request(). """ try: request, client_address = self.get_request() except socket.error: return if self.verify_request(request, client_address): try: self.process_request(request, client_address) except: self.handle_error(request, client_address) self.shutdown_request(request) else: self.shutdown_request(request) 处理请求。 根据上一步骤启动服务器后，服务器便开始监听请求。如果接收到请求信息，便开始处理请求。由_handle_request_noblock()可以看出有几个函数比较重要。 get_request() ——这个函数可以在子类中重写。在TCPServer中，该函数调用监听套接字的accept()方法，返回请求request和客户端地址client_address。 verify_request(request, client_address) ——这个函数可以在子类中重写。该函数返回True表示处理请求，返回False表示忽略请求。 process_request(request, client_address) ——这个函数可以在子类中重写。该函数将调用finish_request()具体完成请求的处理过程，并且在处理完请求后关闭请求。 finish_request(request, client_address) ——该函数将构造一个请求处理类的实例。请求处理类被实例化后将调用其handle()方法处理请求。 3. 进程/线程支持SocketServer模块中还提供了一些”mix-in”类：ForkingMixIn和ThreadingMixIn。这些类可以和服务器类混合使用，很容易改变服务器，为每个请求使用一个单独的进程或线程。具体的服务器类有： class ForkingUDPServer(ForkingMixIn, UDPServer) class ForkingTCPServer(ForkingMixIn, TCPServer) class ThreadingUDPServer(ThreadingMixIn, UDPServer) class ThreadingTCPServer(ThreadingMixIn, TCPServer) class ThreadingUnixStreamServer(ThreadingMixIn, UnixStreamServer) class ThreadingUnixDatagramServer(ThreadingMixIn, UnixDatagramServer) 请求处理类要接收到来的请求以及确定采取什么行动，其中大部分的工作都是由请求处理类完成的。请求处理类负责在套接字层之上实现协议。具体过程为：读取请求、处理请求、写回响应。请求处理类基类中定义了3个方法，子类中需要重写。 setup() ——为请求准备请求处理器 handle() ——对请求完成具体的工作。诸如解析到来的请求，处理数据，并发回响应等。 finish() ——清理setup()期间创建的所有数据 版权声明 Learn Python by Fan Chunke is licensed under a Creative Commons BY-NC-ND 4.0 International License.由Fan Chunke创作并维护的Learn Python博客采用创作共用保留署名-非商业-禁止演绎4.0国际许可证。本文首发于Learn Python 博客（ http://fanchunke.me ），版权所有，侵权必究。本文永久链接：http://fanchunke.me/Python/SocketServer——网络通信服务器/]]></content>
    </entry>

    
  
  
</search>
