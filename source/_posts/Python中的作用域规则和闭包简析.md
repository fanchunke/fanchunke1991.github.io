---
title: Python中的作用域规则和闭包简析
date: 2017-04-14 18:37:03
tags:
    - Python
categories:
    - Python
---


在对Python中的闭包进行简单分析之前，我们先了解一下Python中的作用域规则。关于Python中作用域的详细知识，有很多的博文都进行了介绍。这里我们先从一个简单的例子入手。

### Python中的作用域

假设在交互式命令行中定义如下的函数：

```Python
>>> a = 1
>>> def foo():
        b = 2
        c = 3
        print "locals: %s" % locals()
        return "result: %d" % (a + b +c)
```

<!-- more -->

上述代码先给`a`赋值1，紧接着定义了一个函数：`foo()`。在函数`foo()`中我们定义了两个整数`b`和`c`，函数的返回值为`a`、`b`、`c`三个数的和。

对上述函数进行验证：

```Python
# result
>>> foo()
locals: {'c': 3, 'b': 2}
result: 6
```

根据验证的结果，`foo()`函数的返回值为6。上述的函数定义中只有`b`和`c`两个变量的赋值，那调用函数是如何判断`a`的值呢？这涉及到函数的作用域规则。本文摘录《Python参考手册（第4版）》中的相关论述：

> 每次执行一个函数时， 就会创建心得局部命名空间。该命名空间代表一个局部环境，其中包含函数参数的名称和在函数体内赋值的变量名称。解析这些名称时：
- 解释器将首先搜索局部命名空间；
- 如果没有找到匹配的名称，它就会搜索全局命名空间（函数的全局命名空间始终是定义该函数的模块）；
- 如果解释器在全局命名空间中也找不到匹配值，最终会检查内置命名空间；
- 如果在内置命名空间中也找不到匹配值，就会引发NameError异常。

对应于上面的例子，`foo`函数首先会在局部命名空间中找三个变量的匹配值。上述代码中的`locals()`方法给出了`foo`函数局部命名空间的内容。可以看出，局部命名空间是一个字典，包含`b`和`c`的值，这是因为我们在`foo`函数中定义了这两个变量。然而，局部命名空间中不包含`a`的值，所以就需要在全局命名空间中寻找。可以使用`__globals__`获取一个函数的局部命名空间。

```Python
# foo函数的全局命名空间
>>> foo.__globals__
{'a': 1, '__builtins__': <module '__builtin__' (built-in)>, '__package__': None, '__name__': '__main__', 'foo': <function foo at 0x0000000004613518>, '__doc__': None}
```

`foo`函数的全局命名空间中包含了内置函数模块、`foo`函数、变量`a`以及其他的一些参数。由于在`foo`函数的全局命名空间中找到了变量`a`，`foo`函数便返回三个变量的和。

### 闭包

上述的Python作用域规则具有普遍性。然而，在Python中“一切皆对象”，函数也不例外。这也就是说可以把函数当作参数传递给其他的函数，也可以放在数据结构中，还可以作为函数的返回结果。在这种情况下，Python的作用域规则会发生什么变化呢？我们还是举一个例子：

```Python
>>> def foo():
        a = 1
        def bar():
            b = 2
            c = 3
            return a + b + c
        return bar    
```

在这个例子中，我们定义了一个函数`foo`，并对变量`a`赋值。不过与之前的例子不同的是，在函数`foo`中我们还嵌套了一个函数`bar`，并且还定义了两个变量，这个函数是作为函数`foo`的返回值。根据上面的作用域规则，函数`foo`的局部作用域既不是函数`bar`的局部作用域，也不是它的全局作用域，那函数`bar`能否正确匹配变量`a`的值呢？我们我们来验证一下这个函数是否能够正常运行。

```Python
# 调用函数foo()
>>> bar = foo()
# 返回值bar是一个函数
>>> bar
<function bar at 0x00000000045F3588>
# 调用bar()
>>> bar()
# 结果显示为三个变量之和
6
```
